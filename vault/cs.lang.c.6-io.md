---
id: yj92tn2wp6l2poj7xu2922d
title: 6 输入输出
desc: ''
updated: 1660295040849
created: 1660121562364
---

# 输入输出

## 系统调用

在C语言中嵌入汇编代码，直接进行系统调用；

```c
int main (void){
    int r;
    __asm__ (
        "mov eax, 0x4 \n\t"
        "mov ebx, 0x1 \n\t"
        "mov edx, 0xd \n\t"
        "int 0x80 \n\t"
        : "=a" (r)
        : "c" ("hello.\n")
    );
    return r;
}
```

- 通过`0x80` 中断提供系统调用服务，根据`linux` 系统要求使用`eax`寄存器指定子功能，`0x4` 是写文件和设备；GCC允许的格式之一是将每一行汇编以`\n\t` 结束，并用`""`围住。

- 然后通过`ebx`寄存器指定文件设备，`0x1` 是控制台屏幕；
- `edx` 用于指定写入字符的数量；

**指定写入的内容**：将一个字符数组的地址传递到`ecx`寄存器即可；嵌入式汇编的价值在于它允许寄存器和C语言里面的变量交换数据，但要使用`:` 开头以表示区别；

第一个`:`用于指定输出功能。当系统调用返回后，实际写到屏幕的字符由`eax` 寄存器返回。然而我们已经声明了一个`int`类型的变量`r`，并希望这个字符数保存到变量中：

```c
__asm__(
	: "=a" (r)
)
```

相当于C语言中的表达式：

```c
r = a
```

意思是把`eax`寄存器的内容传送到变量r。等号`=`表示具有破坏原内容的写操作，对`Intel x86` 来说，“a”代表`eax`寄存器；

第二个`:`用于指定输入功能，比如将变量的值传送到寄存器。因此：

```c
__asm__ {
	: "c" ("hello\n")
}
```

的作用是把字符串的首地址传送到`ecx`寄存器，对32位`intel x86`来说，`"c"`是`ecx` 寄存器。字面串`"hello \n"` 首先被用于创建一个不可见数组，然后执行数组——指针转换，并把这个指针的类型的值（地址）传送到`ecx` 寄存器；



最后，汇编指令`int 0x80` 用于发起一个软中断，处理器执行这条指令后，将进入中断处理过程，进入操作系统内部执行。

![image-20220810173358954](https://cdn.notcloud.net/static/md/cy948/202208101733004.png)

### `-masm` 翻译选项

```bash
gcc c0601.c -o c0601.out -masm=intel
./c0601.out
```

`-masm=intel` 意思是使用intel公司的汇编格式；

### 封装打印`char` 数组的函数

```c
int write_string(char * s){
    int l = 0, r;
    
    for (char * p = s; * p ++ != '\0'; l ++);
    
    __asm__ (
        "mov eax, 0x4 \n\t"
        "mov ebx, 0x1 \n\t"
        "int 0x80 \n\t"        
        : "=a" (r)
        : "c" (s), "d" (l)
    );
    
    return r;
}
```

## 编译和链接

### 封装

当前的打印功能可以封装成一个工具：

```c
/******************iotool.c*****************/
int write_string (char * s)
{
    int l = 0, r;

    for (char * p = s; * p ++ != '\0'; l ++) ;

    __asm__ (
                "mov eax, 0x4 \n\t"
                "mov ebx, 0x1 \n\t"
                "int 0x80 \n\t"
                : "=a" (r)
                : "c" (s), "d" (l)
              );

    return r;
}

char * ull_to_string (unsigned long long int n, char * s)
{
    int x = 0;
    char buf [20], * p = s;

    do
        buf [x ++] = n % 10 + '0';
    while (n /= 10);

    do
        * p ++ = buf [-- x];
    while (x);

    * p = '\0';

    return s;
}

unsigned long long int cusum (unsigned long long r)
{
    unsigned long long int sum = 0;

    while (r) sum += r --;

    return sum;
}

```

### 调用

虽然不需要再次写这三个函数的函数体，但仍然需要进行声明，否则会引起编译器错误；

```c
/******************c0603.c*******************/
int write_string (char *);
char * ull_to_string (unsigned long long int, char *);
unsigned long long int cusum (unsigned long long);

int main (void)
{
    write_string ("1+2+3+...+1000=");

    char a [20];

    write_string (ull_to_string (cusum (1000), a));
    write_string ("\n");
}

```

### 编译期链接

一个C程序可以由多个源文件组成。翻译时，C实现将分别翻译源文件，并把它们链接到一起生成可执行的程序。但是，这里的“分别翻译”是有讲究的。

1. 第一个阶段是：编译，对文件的内容进行语法分析，进而生成对应的机器指令。但是对有些实体（如：函数）的解析是无法完成的，因为它们可能并不是在当前源文件内定义的。在这种情况下，C实现将记下这些名字，以及它们的属性（形参及返回参数），等到以后再说。该阶段的成果并不是最终的可执行文件，而是目标文件；
2. 第二阶段是链接，是将前面生成的目标文件链接起来，得到最终的可执行文件，这个阶段将要处理未决的符号（如函数），找到它们的定义。除此之外，还要链接一些与操作系统有关的代码，这些代码对于能否让在生成的可执行程序在操作系统上允许至关重要；

```bash
# 编译
gcc -c c0603.c
gcc -c iotool.c -std=c11 -masm=intel

# 链接
gcc c0603.o iotool.o -o c0603.out

# 运行
./c0603.out
```

`-c` 选项：将文件编译成目标文件（“-o”），一旦位C实现指定了目标文件，则会将这些目标文件链接在一起；

一步到位的操作：

```bash
gcc c0603.c iotool.c \ 
	-o c0603.out \
	-std=c11 \
	-masm=intel
```

## 库

如果一些函数特别有价值，别人都用得上，或者它包含了特殊的算法和秘密，则可以将它们打包成可复用的库。库是包含了机器代码的文件，但它不能单独执行，因为它只是一个功能包，并不具备成为可执行文件所必须的其他组成部分和相关信息。

### 从目标文件生成库

#### 静态库

使用随GCC发行的AR程序，如：

```bash
ar r libiotool.a iotool.o
```

这将从目标文件iotool.o中提取函数，并将它们加入库文件libiotool.a。参数`r`的意思是在库中加入新的函数，如果已经有同名函数则覆盖它。库的名字可以随意指定，建议用“lib”开头，".a"为拓展名；

#### 动态库

和静态库不同，linux 里的另一种库是共享库。共享库在链接时，仅在可执行文件中放一个存根，并不将库中的代码链接到可执行文件中。在这种情况下，生成的可执行文件和动态库有依赖关系，程序执行时，根据需要，可能会加载和执行共享库中的代码。使用共享库不但可以减小可执行文件的体积，也有利于代码的升级。当共享库发行更新的版本时，可以直接替换旧的共享库，而不影响可执行文件：当可执行文件调用共享库的代码时，
执行的是升级后的代码。

以下，我们演示了如何生成共享库，并将它链接到用源文件c0703.c所生成的可执行文件中：

```bash
gcc -shared -o libiotool.so iotool.o
```

`-shared` 用于生成共享库，`-o` 用于指定共享库的名字，可以以"lib"开头，"so"结尾；

```bash
gcc c0603.c libiotool.so -o c0603.out
```

用于使用共享库和源文件c0603.c一起生成可执行文件

```bash
export LD_LIBRARY_PATH=./

./c0603.out # 执行
```

由于可执行程序需要共享库的支持，所以必须要将共享库的位置加入库的搜索路径，否则无法找到。用`export` 命令将当前目录加入搜索库路径的 **环境变量** `LD_LIBRARY_PATH` ；

## 头文件、预处理和翻译单元

>  上述演示了库文件的创建，以及如何在我们的程序中链接库文件。上述有个缺点是：想要用库中的函数，必须现在程序中做不带函数体的声明。在链接阶段，C实现自然会从库中找到这些函数的实现；但库的内容不是人工可以读的，拿到别人的库时，往往不知道怎么使用，更不要谈“声明它”；

库在对外发行的时候，应该同时发行一个头文件。类似于C源文件，头文件是一个文本文件，其最核心的内容是一些声明，比如对库文件里的函数进行声明，按照约定，头文件的后缀是".h"，想要发布"libiotool.a"或者"libiotool.so"，头文件是"iotool.h"，内容如下：

```c
/*iotool.h*/
int write_string(char *);
char * ull_to_string 
    (unsigned long long int, char *);
unsigned long long int cusum
    (unsigned long long);
```

一旦拿到上述头文件，则可以开始进行引入：

```c
/*********************c0604.c*******************/
# include "iotool.h"

# define CHAR_BUF_LEN 20
# define MAX_SUM_NUM 1000
# define FIXED_SUFFIX(x) "1+2+3+...+" #x "="
# define PRN_FIXED_SUFFIX(x) FIXED_SUFFIX(x)

int main (void)
{
    write_string (PRN_FIXED_SUFFIX(MAX_SUM_NUM));

    char a [CHAR_BUF_LEN];
    write_string (ull_to_string (cusum (MAX_SUM_NUM), a));
    write_string ("\n");
}

```

### `#` 预处理命令

预处理指令以`#` 开头，这样就可以将它们与不需要或者不参与预处理的其他文本区分开来。以“`# include` ”打头的预处理指令是源文件包含指令，后面跟一个尖括号“`<>`”或者双引号“`""`”围起来的文件名。在预处理期间，C实现将用该文件的内容来取代这条预处理指令。每个预处理指令都需要独立成行；

#### 宏定义

对于规模较大的程序来说，需要定义一些“关键变量（const）”，`# define` 开头的是宏定义，宏定义分为两种，第一种是变量式的宏定义，`define` 后面的标识符被称为宏名，宏名后面的内容（不好括前后的空格和末尾的换行符）称为替换列表。

```c
# define CHAR_BUF_LEN 20
```

这里的标识符 `CHAR_BUF_LEN` 是宏名，他是替换列表“`20`”的另一个“别名” “标识”，在程序翻译期间，会进行替换

```diff
- char a [CHAR_BUF_LEN];
+ char a [20];
```

但字面串并不能像上面那样。

定义函数：

```c
# define ADD(a, b) (a) + (b)
```

`ADD` 的宏名，`a` 和 `b` 是宏的参数，参数之间用逗号`,` 隔开，此宏一旦定义，则宏调用`ADD(10, 20)` 被拓展为`(10) + (20)`。和函数定义和调用一样，为明确所指，宏定义的参数称为形参，宏调用里的参数为实参；

注意，宏定义里的宏名和组成参数列表的括号之间不能有空白，否则会被视为一个变量定义，宏名之后的部分被视为替换列表；

在函数宏定义中，如果替换列表中有“`#`”，且它后面紧跟着当前宏的形参，则他们在预处理期间被转化为一个字面串，且该字面串是由与该形参对应的实参转化未来，这成为记号串化；

```c
#define STR(x) #x;
```

宏调用`STR(hello) ` 会被拓展为字面串“`hello`”，这个字面串在后续的编译和链接期间会被作为普通串处理。

在函数式定义中，如果替换列表中有"`##`"，且它位于两个记号的中间，则两个记号会被合称为一个记号；如果这两个记号是宏的形参，则将会把它们对应（传入）的实参合并为一个记号，这成为记号黏接。

```c
# define MAKEIDEN(x, y, z) x##y##z
```

则宏调用会被替换为：

```diff
- char MAKEIDEN(a, b, c);
+ char abc;
```

在后续的编译和链接期间，这个拓展的结果会被当成普通的声明一样处理，即，声明一个`char` 类型的变量`abc`；

回到程序中，由于出现在函数式宏定义中的参数才能转化为字面串，所以我们使用了如下宏指令：

```c
# define FIXED_SUFFIX(x) "1+2+3+...+" #x "="
# define PRN_FIXED_SUFFIX(x) FIXED_SUFFIX(x)
```

在预处理阶段，对宏调用的处理是对实参进行宏扩展，然后再对宏调用本身进行拓展。因此，在我们的预期中，一下宏调用：

```c
write_string(FIXED_SUFFIX(MAX_SUM_NUM));
```

将先把`MAX_SUM_NUM` 拓展为1000，接着再扩展宏调用`FIXED_SUFFID(1000)` 最终得到一个黏接的字面串

```
"1+2+3+...+" "1000" "="
```

然而，在函数式宏定义的替换列表（宏体）中，如果形参前面是"#"或者"##"，又或者后面是"##"，则调用此宏时，传入的实参并不拓展。因此，上述宏调用实际上会被拓展为L

```
"1+2+3+...+" "MAX_SUM_SUM" "="
```

对此，比较标准的解决方法是：先顶一个替换列表中没有的"#"或者"##"的宏，这样就可以将拓展后的实参传进来，然后再将拓展后的实参传递给前面所定义的宏`FIXED_SUFFIX` ：

```c
# define PRN_FIXED_SUFFIX(x) FIXED_SUFFIX(x)
```

在正式编译一个C程序之前，要先进行预处理。预处理之后，所有的预处理指令都被删除，源文件经过预处理之后就得到了翻译单元。换句话说，对源文件进行预处理的成果是生成了翻译单元；

在实现将一个源文件翻译成可执行文件的整个过程里，如果没有特别的指示，翻译单元指示翻译过程早期的一个临时文件，用于后续的编译过程，用完就删。需要`-E` 参数停止翻译过程并显示预处理过程的结果：

```bash
gcc -E c0604.c
```

![image-20220811224642175](https://cdn.notcloud.net/static/md/cy948/202208112246228.png)

`-E` 选项的意思是在预处理之后立即停止翻译过程，不进行后续的编译过程。在输出的内容里有一些行标记信息，我们用斜体显示，如果要想将预处理的结果保存为文件，可以用“-o”选项指定一个文件名；

无论如何，经过预处理之后，在生成的翻译单元格将不再包含预处理指令，头文件的内容也已经包含进来，而所有的宏也已经被展开，整个翻译单元仅剩下声明和函数定义。

### Checkpoint6.1

给定宏定义

```c
# define pst(x, y, z) x##y##z
```

则宏调用`pst (_, int, _)` 拓展之后的结果是什么？如果想要得到`_int_` ，则应当如何修改宏定义？

```c
# define pst
```

## UNIX和类UNIX函数库

C和Unix是近亲，最初发明C是为了重写Unix，Unix系统调用使用C库封装进行使用。因兼容需要，IEEE牵头建立一个标准，POSIX，对Unix的各个分支加以规范和认证，其中包括C语言的函数库。

统一后的Unix编程接口按功能进行分类，并以头文件的形式发布。库函数的具体实现，有些库函数是Unix系统调用的封装，而有些库函数不依赖于系统调用而独立存在，如：计算字符串长度，可以用C或者汇编实现。

### 限定的类型

```c
int open(const char * pathname, int oflag,...);
```

函数`open` 的第一个参数用于指定要创建或者打开的文件名，故其类型是指向char的指针，用于指向一个字符串。但事实上，该参数的类型并不是指向char的指针，二是指向`const char` 的指针?

C语言里的类型，从所描述的实体来分，可分为变量类型和函数类型，而变量类型又拥有它们的限定版本。也就是说，它们可以用一些关键字如：“const”等加以限定，从而形成各自的限定版本，而这些关键字称为类型限定符。例如，`const int` 是int类型的限定版本；

`const` 的意思是：只读，只用于读出而禁止写入；

```c
const unsigned int cx = 0;
```

这就声明一个`const unsigned int` 类型的变量`cx` 并初始化为0。如果一个变量的类型是`const` 限定的，这种限定不影响它的初始化，但不允许写入操作。因此，下面的语句是非法的，将导致它的程序里无法通过编译；

```c
cx = 65533;
```

> 缓存的意义：如果仅仅是为了限制写入一个变量，则发明关键字“cosnt”是没有任何实际用处的，因为我们可以直接使用常量，比如整型常量和字符常量；即使担心同一个常量被多处使用而难以维护，也可以通过宏定义来解决。实际上，它真正的用处和目的是对程序的翻译进行优化。

我们知道，处理器内部的寄存器速度最快，外部存储器的速度则慢得多。如果一个变量仅用于读出（而不是写入），则它的值只读一次即可，不必在每次用到变量的值时，都真的执行一次存储器读出操作。换句话说，它只需要在开始的时候读一次，然后在寄存器里缓存这个值即可。

但是，C实现需要程序员给出一个字面上的保证，以表明自己不会写入某个变量，这就是关键字“const”。如果一个变量具有const限定的类型，则意味着程序员不准备写入这个变量，而只是读它的值，因此，C实现可以尽可能地多做一些优化。比如，它可以在第一次访问变量的同时将它的值缓存起来，以后只需要使用这个缓存值而不需要在读取操作上浪费时间。

指针所指向的类型和数组类型也可以是限定的类型。因为数组的类型其实是其元素的类型，所以，声明一个限定类型的数组也就意味着它的元素也具有相同的限定的。在实例中，数组 `ca` 是具有2个`const int`类型的元素的数组，而指针`pc` 则是指向`const int`类型的变量的指针；

```c
const int ca [2];
const int * pc = ca;
```

对`pc` 的声明应该从标识符开始，一次往左读为“变量PC的类型是指针，该指针指向const int” 或者说：“变量pc的类型是指向const int的指针”；

![image-20220812111853341](https://cdn.notcloud.net/static/md/cy948/202208121118384.png)

变量`pc` 的声明中，作为初始化器，数组`ca` 转换为指向其首元素的指针。类型为`const char *`，以下语句是非法的：

```c
* pc = 77;
ca[1] = 103;
```

这里，左值`pc`的类型是`const char *` 经左值转换的得到同类型的指针（指），故表达式`* pc` 也是一个左值，类型为`const char` 指示一个`const char` 类型的变量，实际上是数组`ca` 的元素，该变量不可写；

虽然使用`const` 限定的类型来声明变量能够增强程序的可读性并在一定程度上保护变量值不被破坏，然而并非完全保护，如：

```c
const int c = 0;
```

因为变量`c` 的类型是`const int` 故下面的语句是非法的

```c
c = 1;
```

但是，可以用一元`& `运算符得到一个指向`c` 的指针，然后通过转型表达式得到一个指向`int` 的指针，并通过这个指针来简介修改`c`的值；

```c
* (int *) & c = 123;
```

这里，表达式`& c`的结果是指向`const int`的指针`const int *`； 转型表达式`(int *) & c` 强制将其类型转为`int *`，然后`*` 作用于指针，得到一个左值，实际上代表变量`c`；

>  这样做在语法层面没有问题，但`const` 变量可能加载到一个被程序限制的“不可写”区域或写入不立即生效的区域，引发未定义行为；

#### Checkpoint6.2

对于上述变量`c`，既然通过类型转换就可以突破`const ` 的限制写入变量，那为什么以下操作不可以呢？

```c
(int) c = 1003;
```

> 这个直接对变量的左值类型进行转换，是不合法的；

如果一个扁你狼类型是指针，那么，不但它指向的类型可以是限定的，而且这个指针本身也可以是限定的。

```c
int c = 0, d = 0;
const int * const cpc = & c;
```

![image-20220812163502509](https://cdn.notcloud.net/static/md/cy948/202208121635544.png)

从标识符`cpc`开始，一次向左读为“`cpc`的类型是const指针，（该指针）指向const int”，或者说“变量`cpc`的类型是一个指向`const int`类型的const指针”。所以，`cpc` 的类型是`const int * const` ，即指向`const int`的`const`指针变量；

像`cpc`这样的变量，不但不允许通过它写入的值所指向的那个变量，而且也不允许修改它本身的值。换句话说，变量`cpc`只能在声明的时候初始化为指向某个变量，此后不允许再指向别的变量，也不允许修改它的值所指向的变量。因此，以下语句非法：

```c
cpc = & d;
* cpc = 123;
```

函数的形参也可以被声明为限定的类型。再下面程序中，函数`preld` 有两个参数`cpc` 和 `ci` 。形参`cpc` 是`const` 限定的指针变量，形参`ci`是`const` 限定的整型变量。

```c
int preld(int * const cpc, const int ci){
    return * cpc + ci;
}
```

虽然形参是限定变量，但在调用函数传入形参的时候，并不受限制，可以正常赋值，但在函数内部不允许修改；

#### Checkpoint6.3

1. 若变量ac是具有5个元素的数组，且元素类型为指向const char的指针，请写出它的声明。

```c
const char ac [5];
```

2. 若变量ca是具有5个元素的数组，且元素类型为指向const char的const指针，请写出它的声明。

```c
const char * const ca [5];
```

3. 若变量p是一个const指针，指向一个5元素的数组，数组的元素类型为指向const char的指针，请写出p的声明。进一步地，如果元素类型为指向const char的const指针呢？

```c
const char * const p [5];
```

### 变参函数

```c
int open(const char * pathname, int oflag,...);
```

回到`open`函数，它的第二个参数用于指定文件打开的方式，比如是创建文件呢，还是纯粹打开文件；如果是创建文件，则文件已经存在怎么办；打开文件的目的是只读还是读写，这个参数类型是int；

仔细观察，函数`open`的声明和我们学习过的函数不同，它的末尾是“...”，意味着后面还可以有其他更多的参数。这样的函数，它们在参数类型和数量上不确定，称为“**变参函数**”或“可变参函数”。**变参函数**至少有一个类型确定的参数，而且必须是最开是参数，后面的参数无法确定。因为这个原因，参数类型列表必须以`, ...` 结尾；

下面是一个使用变参函数的例子，但它有一定的特殊性，那就是只能在某些特定的计算机上正确执行，比如基于32位Intelx86处理器的计算机系统。至于原因，我们后面将会讲到，而且还将提供一个安全、通用的解决方案。

```c
/*****************c0606.c*****************/
long long int sum_ints (unsigned int count, ...)
{
    int * var_start = (int *) & count + 1;
    long long int sum = 0;

    while (count --) sum += * var_start ++;

    return sum;
}

int main (void)
{
    long long int x, y, z;

    x = sum_ints (2, 100, 200);
    y = sum_ints (0);
    z = sum_ints (5, 10, -10, 30, 600, -300);
}
```

