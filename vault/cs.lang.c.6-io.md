---
id: yj92tn2wp6l2poj7xu2922d
title: 6 输入输出
desc: ''
updated: 1660295040849
created: 1660121562364
---

# 输入输出

## 系统调用

在C语言中嵌入汇编代码，直接进行系统调用；

```c
int main (void){
    int r;
    __asm__ (
        "mov eax, 0x4 \n\t"
        "mov ebx, 0x1 \n\t"
        "mov edx, 0xd \n\t"
        "int 0x80 \n\t"
        : "=a" (r)
        : "c" ("hello.\n")
    );
    return r;
}
```

- 通过`0x80` 中断提供系统调用服务，根据`linux` 系统要求使用`eax`寄存器指定子功能，`0x4` 是写文件和设备；GCC允许的格式之一是将每一行汇编以`\n\t` 结束，并用`""`围住。

- 然后通过`ebx`寄存器指定文件设备，`0x1` 是控制台屏幕；
- `edx` 用于指定写入字符的数量；

**指定写入的内容**：将一个字符数组的地址传递到`ecx`寄存器即可；嵌入式汇编的价值在于它允许寄存器和C语言里面的变量交换数据，但要使用`:` 开头以表示区别；

第一个`:`用于指定输出功能。当系统调用返回后，实际写到屏幕的字符由`eax` 寄存器返回。然而我们已经声明了一个`int`类型的变量`r`，并希望这个字符数保存到变量中：

```c
__asm__(
	: "=a" (r)
)
```

相当于C语言中的表达式：

```c
r = a
```

意思是把`eax`寄存器的内容传送到变量r。等号`=`表示具有破坏原内容的写操作，对`Intel x86` 来说，“a”代表`eax`寄存器；

第二个`:`用于指定输入功能，比如将变量的值传送到寄存器。因此：

```c
__asm__ {
	: "c" ("hello\n")
}
```

的作用是把字符串的首地址传送到`ecx`寄存器，对32位`intel x86`来说，`"c"`是`ecx` 寄存器。字面串`"hello \n"` 首先被用于创建一个不可见数组，然后执行数组——指针转换，并把这个指针的类型的值（地址）传送到`ecx` 寄存器；



最后，汇编指令`int 0x80` 用于发起一个软中断，处理器执行这条指令后，将进入中断处理过程，进入操作系统内部执行。

![image-20220810173358954](https://cdn.notcloud.net/static/md/cy948/202208101733004.png)

### `-masm` 翻译选项

```bash
gcc c0601.c -o c0601.out -masm=intel
./c0601.out
```

`-masm=intel` 意思是使用intel公司的汇编格式；

### 封装打印`char` 数组的函数

```c
int write_string(char * s){
    int l = 0, r;
    
    for (char * p = s; * p ++ != '\0'; l ++);
    
    __asm__ (
        "mov eax, 0x4 \n\t"
        "mov ebx, 0x1 \n\t"
        "int 0x80 \n\t"        
        : "=a" (r)
        : "c" (s), "d" (l)
    );
    
    return r;
}
```

## 编译和链接

### 封装

当前的打印功能可以封装成一个工具：

```c
/******************iotool.c*****************/
int write_string (char * s)
{
    int l = 0, r;

    for (char * p = s; * p ++ != '\0'; l ++) ;

    __asm__ (
                "mov eax, 0x4 \n\t"
                "mov ebx, 0x1 \n\t"
                "int 0x80 \n\t"
                : "=a" (r)
                : "c" (s), "d" (l)
              );

    return r;
}

char * ull_to_string (unsigned long long int n, char * s)
{
    int x = 0;
    char buf [20], * p = s;

    do
        buf [x ++] = n % 10 + '0';
    while (n /= 10);

    do
        * p ++ = buf [-- x];
    while (x);

    * p = '\0';

    return s;
}

unsigned long long int cusum (unsigned long long r)
{
    unsigned long long int sum = 0;

    while (r) sum += r --;

    return sum;
}

```

### 调用

虽然不需要再次写这三个函数的函数体，但仍然需要进行声明，否则会引起编译器错误；

```c
/******************c0603.c*******************/
int write_string (char *);
char * ull_to_string (unsigned long long int, char *);
unsigned long long int cusum (unsigned long long);

int main (void)
{
    write_string ("1+2+3+...+1000=");

    char a [20];

    write_string (ull_to_string (cusum (1000), a));
    write_string ("\n");
}

```

### 编译期链接

一个C程序可以由多个源文件组成。翻译时，C实现将分别翻译源文件，并把它们链接到一起生成可执行的程序。但是，这里的“分别翻译”是有讲究的。

1. 第一个阶段是：编译，对文件的内容进行语法分析，进而生成对应的机器指令。但是对有些实体（如：函数）的解析是无法完成的，因为它们可能并不是在当前源文件内定义的。在这种情况下，C实现将记下这些名字，以及它们的属性（形参及返回参数），等到以后再说。该阶段的成果并不是最终的可执行文件，而是目标文件；
2. 第二阶段是链接，是将前面生成的目标文件链接起来，得到最终的可执行文件，这个阶段将要处理未决的符号（如函数），找到它们的定义。除此之外，还要链接一些与操作系统有关的代码，这些代码对于能否让在生成的可执行程序在操作系统上允许至关重要；

```bash
# 编译
gcc -c c0603.c
gcc -c iotool.c -std=c11 -masm=intel

# 链接
gcc c0603.o iotool.o -o c0603.out

# 运行
./c0603.out
```

`-c` 选项：将文件编译成目标文件（“-o”），一旦位C实现指定了目标文件，则会将这些目标文件链接在一起；

一步到位的操作：

```bash
gcc c0603.c iotool.c \ 
	-o c0603.out \
	-std=c11 \
	-masm=intel
```

## 库

如果一些函数特别有价值，别人都用得上，或者它包含了特殊的算法和秘密，则可以将它们打包成可复用的库。库是包含了机器代码的文件，但它不能单独执行，因为它只是一个功能包，并不具备成为可执行文件所必须的其他组成部分和相关信息。

### 从目标文件生成库

#### 静态库

使用随GCC发行的AR程序，如：

```bash
ar r libiotool.a iotool.o
```

这将从目标文件iotool.o中提取函数，并将它们加入库文件libiotool.a。参数`r`的意思是在库中加入新的函数，如果已经有同名函数则覆盖它。库的名字可以随意指定，建议用“lib”开头，".a"为拓展名；

#### 动态库

和静态库不同，linux 里的另一种库是共享库。共享库在链接时，仅在可执行文件中放一个存根，并不将库中的代码链接到可执行文件中。在这种情况下，生成的可执行文件和动态库有依赖关系，程序执行时，根据需要，可能会加载和执行共享库中的代码。使用共享库不但可以减小可执行文件的体积，也有利于代码的升级。当共享库发行更新的版本时，可以直接替换旧的共享库，而不影响可执行文件：当可执行文件调用共享库的代码时，
执行的是升级后的代码。

以下，我们演示了如何生成共享库，并将它链接到用源文件c0703.c所生成的可执行文件中：

```bash
gcc -shared -o libiotool.so iotool.o
```

`-shared` 用于生成共享库，`-o` 用于指定共享库的名字，可以以"lib"开头，"so"结尾；

```bash
gcc c0603.c libiotool.so -o c0603.out
```

用于使用共享库和源文件c0603.c一起生成可执行文件

```bash
export LD_LIBRARY_PATH=./

./c0603.out # 执行
```

由于可执行程序需要共享库的支持，所以必须要将共享库的位置加入库的搜索路径，否则无法找到。用`export` 命令将当前目录加入搜索库路径的 **环境变量** `LD_LIBRARY_PATH` ；

## 头文件、预处理和翻译单元

>  上述演示了库文件的创建，以及如何在我们的程序中链接库文件。上述有个缺点是：想要用库中的函数，必须现在程序中做不带函数体的声明。在链接阶段，C实现自然会从库中找到这些函数的实现；但库的内容不是人工可以读的，拿到别人的库时，往往不知道怎么使用，更不要谈“声明它”；

库在对外发行的时候，应该同时发行一个头文件。类似于C源文件，头文件是一个文本文件，其最核心的内容是一些声明，比如对库文件里的函数进行声明，按照约定，头文件的后缀是".h"，想要发布"libiotool.a"或者"libiotool.so"，头文件是"iotool.h"，内容如下：

```c
/*iotool.h*/
int write_string(char *);
char * ull_to_string 
    (unsigned long long int, char *);
unsigned long long int cusum
    (unsigned long long);
```

一旦拿到上述头文件，则可以开始进行引入：

```c
/*********************c0604.c*******************/
# include "iotool.h"

# define CHAR_BUF_LEN 20
# define MAX_SUM_NUM 1000
# define FIXED_SUFFIX(x) "1+2+3+...+" #x "="
# define PRN_FIXED_SUFFIX(x) FIXED_SUFFIX(x)

int main (void)
{
    write_string (PRN_FIXED_SUFFIX(MAX_SUM_NUM));

    char a [CHAR_BUF_LEN];
    write_string (ull_to_string (cusum (MAX_SUM_NUM), a));
    write_string ("\n");
}

```

### `#` 预处理命令

预处理指令以`#` 开头，这样就可以将它们与不需要或者不参与预处理的其他文本区分开来。以“`# include` ”打头的预处理指令是源文件包含指令，后面跟一个尖括号“`<>`”或者双引号“`""`”围起来的文件名。在预处理期间，C实现将用该文件的内容来取代这条预处理指令。每个预处理指令都需要独立成行；

#### 宏定义

对于规模较大的程序来说，需要定义一些“关键变量（const）”，`# define` 开头的是宏定义，宏定义分为两种，第一种是变量式的宏定义，`define` 后面的标识符被称为宏名，宏名后面的内容（不好括前后的空格和末尾的换行符）称为替换列表。

```c
# define CHAR_BUF_LEN 20
```

这里的标识符 `CHAR_BUF_LEN` 是宏名，他是替换列表“`20`”的另一个“别名” “标识”，在程序翻译期间，会进行替换

```diff
- char a [CHAR_BUF_LEN];
+ char a [20];
```

但字面串并不能像上面那样。

定义函数：

```c
# define ADD(a, b) (a) + (b)
```

`ADD` 的宏名，`a` 和 `b` 是宏的参数，参数之间用逗号`,` 隔开，此宏一旦定义，则宏调用`ADD(10, 20)` 被拓展为`(10) + (20)`。和函数定义和调用一样，为明确所指，宏定义的参数称为形参，宏调用里的参数为实参；

注意，宏定义里的宏名和组成参数列表的括号之间不能有空白，否则会被视为一个变量定义，宏名之后的部分被视为替换列表；

在函数宏定义中，如果替换列表中有“`#`”，且它后面紧跟着当前宏的形参，则他们在预处理期间被转化为一个字面串，且该字面串是由与该形参对应的实参转化未来，这成为记号串化；

```c
#define STR(x) #x;
```

宏调用`STR(hello) ` 会被拓展为字面串“`hello`”，这个字面串在后续的编译和链接期间会被作为普通串处理。

在函数式定义中，如果替换列表中有"`##`"，且它位于两个记号的中间，则两个记号会被合称为一个记号；如果这两个记号是宏的形参，则将会把它们对应（传入）的实参合并为一个记号，这成为记号黏接。

```c
# define MAKEIDEN(x, y, z) x##y##z
```

则宏调用会被替换为：

```diff
- char MAKEIDEN(a, b, c);
+ char abc;
```

在后续的编译和链接期间，这个拓展的结果会被当成普通的声明一样处理，即，声明一个`char` 类型的变量`abc`；

回到程序中，由于出现在函数式宏定义中的参数才能转化为字面串，所以我们使用了如下宏指令：

```c
# define FIXED_SUFFIX(x) "1+2+3+...+" #x "="
# define PRN_FIXED_SUFFIX(x) FIXED_SUFFIX(x)
```

在预处理阶段，对宏调用的处理是对实参进行宏扩展，然后再对宏调用本身进行拓展。因此，在我们的预期中，一下宏调用：

```c
write_string(FIXED_SUFFIX(MAX_SUM_NUM));
```

将先把`MAX_SUM_NUM` 拓展为1000，接着再扩展宏调用`FIXED_SUFFID(1000)` 最终得到一个黏接的字面串

```
"1+2+3+...+" "1000" "="
```

然而，在函数式宏定义的替换列表（宏体）中，如果形参前面是"#"或者"##"，又或者后面是"##"，则调用此宏时，传入的实参并不拓展。因此，上述宏调用实际上会被拓展为L

```
"1+2+3+...+" "MAX_SUM_SUM" "="
```

对此，比较标准的解决方法是：先顶一个替换列表中没有的"#"或者"##"的宏，这样就可以将拓展后的实参传进来，然后再将拓展后的实参传递给前面所定义的宏`FIXED_SUFFIX` ：

```c
# define PRN_FIXED_SUFFIX(x) FIXED_SUFFIX(x)
```

在正式编译一个C程序之前，要先进行预处理。预处理之后，所有的预处理指令都被删除，源文件经过预处理之后就得到了翻译单元。换句话说，对源文件进行预处理的成果是生成了翻译单元；

在实现将一个源文件翻译成可执行文件的整个过程里，如果没有特别的指示，翻译单元指示翻译过程早期的一个临时文件，用于后续的编译过程，用完就删。需要`-E` 参数停止翻译过程并显示预处理过程的结果：

```bash
gcc -E c0604.c
```

![image-20220811224642175](https://cdn.notcloud.net/static/md/cy948/202208112246228.png)

`-E` 选项的意思是在预处理之后立即停止翻译过程，不进行后续的编译过程。在输出的内容里有一些行标记信息，我们用斜体显示，如果要想将预处理的结果保存为文件，可以用“-o”选项指定一个文件名；

无论如何，经过预处理之后，在生成的翻译单元格将不再包含预处理指令，头文件的内容也已经包含进来，而所有的宏也已经被展开，整个翻译单元仅剩下声明和函数定义。

### Checkpoint6.1

给定宏定义

```c
# define pst(x, y, z) x##y##z
```

则宏调用`pst (_, int, _)` 拓展之后的结果是什么？如果想要得到`_int_` ，则应当如何修改宏定义？

```c
# define pst
```

## UNIX和类UNIX函数库

C和Unix是近亲，最初发明C是为了重写Unix，Unix系统调用使用C库封装进行使用。因兼容需要，IEEE牵头建立一个标准，POSIX，对Unix的各个分支加以规范和认证，其中包括C语言的函数库。

统一后的Unix编程接口按功能进行分类，并以头文件的形式发布。库函数的具体实现，有些库函数是Unix系统调用的封装，而有些库函数不依赖于系统调用而独立存在，如：计算字符串长度，可以用C或者汇编实现。

### 限定的类型

```c
int open(const char * pathname, int oflag,...);
```

函数`open` 的第一个参数用于指定要创建或者打开的文件名，故其类型是指向char的指针，用于指向一个字符串。但事实上，该参数的类型并不是指向char的指针，二是指向`const char` 的指针?

C语言里的类型，从所描述的实体来分，可分为变量类型和函数类型，而变量类型又拥有它们的限定版本。也就是说，它们可以用一些关键字如：“const”等加以限定，从而形成各自的限定版本，而这些关键字称为类型限定符。例如，`const int` 是int类型的限定版本；

`const` 的意思是：只读，只用于读出而禁止写入；

```c
const unsigned int cx = 0;
```

这就声明一个`const unsigned int` 类型的变量`cx` 并初始化为0。如果一个变量的类型是`const` 限定的，这种限定不影响它的初始化，但不允许写入操作。因此，下面的语句是非法的，将导致它的程序里无法通过编译；

```c
cx = 65533;
```

> 缓存的意义：如果仅仅是为了限制写入一个变量，则发明关键字“cosnt”是没有任何实际用处的，因为我们可以直接使用常量，比如整型常量和字符常量；即使担心同一个常量被多处使用而难以维护，也可以通过宏定义来解决。实际上，它真正的用处和目的是对程序的翻译进行优化。

我们知道，处理器内部的寄存器速度最快，外部存储器的速度则慢得多。如果一个变量仅用于读出（而不是写入），则它的值只读一次即可，不必在每次用到变量的值时，都真的执行一次存储器读出操作。换句话说，它只需要在开始的时候读一次，然后在寄存器里缓存这个值即可。

但是，C实现需要程序员给出一个字面上的保证，以表明自己不会写入某个变量，这就是关键字“const”。如果一个变量具有const限定的类型，则意味着程序员不准备写入这个变量，而只是读它的值，因此，C实现可以尽可能地多做一些优化。比如，它可以在第一次访问变量的同时将它的值缓存起来，以后只需要使用这个缓存值而不需要在读取操作上浪费时间。

指针所指向的类型和数组类型也可以是限定的类型。因为数组的类型其实是其元素的类型，所以，声明一个限定类型的数组也就意味着它的元素也具有相同的限定的。在实例中，数组 `ca` 是具有2个`const int`类型的元素的数组，而指针`pc` 则是指向`const int`类型的变量的指针；

```c
const int ca [2];
const int * pc = ca;
```

对`pc` 的声明应该从标识符开始，一次往左读为“变量PC的类型是指针，该指针指向const int” 或者说：“变量pc的类型是指向const int的指针”；

![image-20220812111853341](https://cdn.notcloud.net/static/md/cy948/202208121118384.png)

变量`pc` 的声明中，作为初始化器，数组`ca` 转换为指向其首元素的指针。类型为`const char *`，以下语句是非法的：

```c
* pc = 77;
ca[1] = 103;
```

这里，左值`pc`的类型是`const char *` 经左值转换的得到同类型的指针（指），故表达式`* pc` 也是一个左值，类型为`const char` 指示一个`const char` 类型的变量，实际上是数组`ca` 的元素，该变量不可写；

虽然使用`const` 限定的类型来声明变量能够增强程序的可读性并在一定程度上保护变量值不被破坏，然而并非完全保护，如：

```c
const int c = 0;
```

因为变量`c` 的类型是`const int` 故下面的语句是非法的

```c
c = 1;
```

但是，可以用一元`& `运算符得到一个指向`c` 的指针，然后通过转型表达式得到一个指向`int` 的指针，并通过这个指针来简介修改`c`的值；

```c
* (int *) & c = 123;
```

这里，表达式`& c`的结果是指向`const int`的指针`const int *`； 转型表达式`(int *) & c` 强制将其类型转为`int *`，然后`*` 作用于指针，得到一个左值，实际上代表变量`c`；

>  这样做在语法层面没有问题，但`const` 变量可能加载到一个被程序限制的“不可写”区域或写入不立即生效的区域，引发未定义行为；

#### Checkpoint6.2

对于上述变量`c`，既然通过类型转换就可以突破`const ` 的限制写入变量，那为什么以下操作不可以呢？

```c
(int) c = 1003;
```

> 这个直接对变量的左值类型进行转换，是不合法的；

如果一个扁你狼类型是指针，那么，不但它指向的类型可以是限定的，而且这个指针本身也可以是限定的。

```c
int c = 0, d = 0;
const int * const cpc = & c;
```

![image-20220812163502509](https://cdn.notcloud.net/static/md/cy948/202208121635544.png)

从标识符`cpc`开始，一次向左读为“`cpc`的类型是const指针，（该指针）指向const int”，或者说“变量`cpc`的类型是一个指向`const int`类型的const指针”。所以，`cpc` 的类型是`const int * const` ，即指向`const int`的`const`指针变量；

像`cpc`这样的变量，不但不允许通过它写入的值所指向的那个变量，而且也不允许修改它本身的值。换句话说，变量`cpc`只能在声明的时候初始化为指向某个变量，此后不允许再指向别的变量，也不允许修改它的值所指向的变量。因此，以下语句非法：

```c
cpc = & d;
* cpc = 123;
```

函数的形参也可以被声明为限定的类型。再下面程序中，函数`preld` 有两个参数`cpc` 和 `ci` 。形参`cpc` 是`const` 限定的指针变量，形参`ci`是`const` 限定的整型变量。

```c
int preld(int * const cpc, const int ci){
    return * cpc + ci;
}
```

虽然形参是限定变量，但在调用函数传入形参的时候，并不受限制，可以正常赋值，但在函数内部不允许修改；

#### Checkpoint6.3

1. 若变量ac是具有5个元素的数组，且元素类型为指向const char的指针，请写出它的声明。

```c
const char ac [5];
```

2. 若变量ca是具有5个元素的数组，且元素类型为指向const char的const指针，请写出它的声明。

```c
const char * const ca [5];
```

3. 若变量p是一个const指针，指向一个5元素的数组，数组的元素类型为指向const char的指针，请写出p的声明。进一步地，如果元素类型为指向const char的const指针呢？

```c
const char * const p [5];
```

### 变参函数

```c
int open(const char * pathname, int oflag,...);
```

回到`open`函数，它的第二个参数用于指定文件打开的方式，比如是创建文件呢，还是纯粹打开文件；如果是创建文件，则文件已经存在怎么办；打开文件的目的是只读还是读写，这个参数类型是int；

仔细观察，函数`open`的声明和我们学习过的函数不同，它的末尾是“...”，意味着后面还可以有其他更多的参数。这样的函数，它们在参数类型和数量上不确定，称为“**变参函数**”或“可变参函数”。**变参函数**至少有一个类型确定的参数，而且必须是最开是参数，后面的参数无法确定。因为这个原因，参数类型列表必须以`, ...` 结尾；

下面是一个使用变参函数的例子，但它有一定的特殊性，那就是只能在某些特定的计算机上正确执行，比如基于32位Intelx86处理器的计算机系统。至于原因，我们后面将会讲到，而且还将提供一个安全、通用的解决方案。

```c
/*****************c0606.c*****************/
long long int sum_ints (unsigned int count, ...)
{
    int * var_start = (int *) & count + 1;
    long long int sum = 0;

    while (count --) sum += * var_start ++;

    return sum;
}

int main (void)
{
    long long int x, y, z;

    x = sum_ints (2, 100, 200);
    y = sum_ints (0);
    z = sum_ints (5, 10, -10, 30, 600, -300);
}
```

在程序中，`sum_ints` 是变参函数，用于累加传入的整数，**C语言规定每个函数的参数数量上限不小于127个**。

在基于32位Intelx86平台处理器的系统中，C实现会确保变参函数的参数是按顺序传递并集中保存至一个特定的存储区里，函数嗲用着把需要传递的参数存放在这里，而函数也从这里取得参数的值（访问参数变量）。因此，只需要获得第一个参数的地址，就能访问剩余的参数；

![image-20220813111131301](https://cdn.notcloud.net/static/md/cy948/202208131111345.png)

#### 手工获取可变参数

- 生成一个指向第一个变量count的指针，并将这个指针移动到变量count之后，使其指向第一个可变参数，用来初始化变量var_start:

```c
int * var_start = (int *) & count + 1;
```

先来看初始化器`(int *) & count + 1`， 一元`&` 运算符的优先级最高，转型运算符次之，加性运算符`+` 的优先级最低。表达式`& count` 是生成一个指针，指向值为2的参数变量。这个指针+1就得到一个新指针，指向第一个参数变量；

指针的类型决定了能从所指向变量里读取什么样的值，表达式`& count` 的类型是指向`unsigned int` 的指针，但我们需要一个指向`int` 的指针，因为后面的变参都是`int`类型。为此，需要用转型表达式将表达式`& count` 的值从指向`unsigned int`类型的指针转换为指向`int`的指针；

```c
while (count --) sum += * var_start ++;
```

`while` 语句用于利用使用者指定的参数个数依次读取参数并进行计算；

#### 通过stdarg库获取可变参数

但上述方法存在问题，没有考虑到跨平台的兼容性，先不说每个可变参数是否是挨在一起，变量的对齐也是一个问题。stdarg库符合POSIX标准，提供了获取可变参数的实现；下面将使用该库改善可移植性：

```c
/*****************c0607.c****************/
# include <stdarg.h>

typedef long long int VARF (unsigned int, ...);

int main (void)
{
    long long int x, y, z, m, n;

    VARF sum_ints;
    x = sum_ints (2, 100, 200);
    y = sum_ints (0);
    z = sum_ints (5, 10, -10, 30, 600, -300);
}

long long int sum_ints (unsigned int count, ...)
{
    long long int sum = 0;

    va_list ap;
    va_start(ap, count);
    while (count --) sum += va_arg(ap, int);
    va_end(ap);

    return sum;
}

```

在该程序中，源文件包含指令`# include`的用法和前面的不一样：

```c
# include "iotool.h"
```

这里用的是双引号，而当前程序中用的是尖括号。预处理指令`# include` 指明了要包含的文件，预处理器需要知道文件的位置。C实现都会提供一些流行的函数库，有针对Unix和类Unix 的POSIX函数库等等，这些库文件的头文件会出现在特定位置，由C实现定义的位置；

- 如果由`<>`围住的，C实现将找到这个实现定义的位置去寻找它；
- 如果是由`""` 围住的，则C实现会用别的方法寻找它，如：在当前目录下寻找，如果找不到再当成`<>`围起来的文件名处理；

可移植性：我们知道C语言具有非凡的可移植性，用它编写的程序，能够在不同的计算机系统上翻译和执行。但是，说白了，所谓的可移植性，就是在那种计算机系统上有可用的C实现，能够将程序翻译成符合那个计算机系统的可执行程序。

>  所谓C语言具有很强的可移植性，无非就是有很多好事者为各种不同的计算机系统编写了大量的C实现。

定制性：C实现也是程序，为一种计算机系统提供的C实现不能在另一种不同的计算机系统上工作。就像你不能把windows上的Word文字处理软件拿到Linux上运行一样，为Windows提供的C实现不能在Linux上运行；GCC的Linux版本也不能直接拿到Windows操作系统上运行；Gcc的64位Linux版本也不能拿到32位的Linux操作系统上开工。

> 所以，C实现具有“定制性”的特征，你要安装C实现，第一步就是选择适合你当前计算机系统的那个版本。由于这个原因，不同的C实现就可以针对它所运行的计算机系统来定制一些内容。

##### 类型定义

```c
long long int sum_ints (unsigned int count, ...)
{
    long long int sum = 0;

    va_list ap;
    va_start(ap, count);
    while (count --) sum += va_arg(ap, int);
    va_end(ap);

    return sum;
}
```

在`sum_ints`函数中，先声明了一个`va_list`类型的变量`ap`，用来保存指向参数的指针，相当于我们前面的`var_start`。不同的计算机系统上有不同的C实现，而`va_list`的定义则随C实现的不同而有所变化。在基于32位intelx86处理器的计算机系统上，C实现有可能将它定义为：

```c
typedef char * va_list;
```

`typedef`是C语言的关键字，它唯一的作用是类型定义，也就是将一个标识符定义位它被声明的那种类型。完成类型定义后，可以使用这个类型变量：

```c
va_list vla; // 等价于 char * vla;
va_list func(va_list); // 等价于 char * func(char *);
```

可以定义任何类型的别名。如：

```c
typedef int DWORD;
typedef DWORD dWord;
typedef char * PCHAR;
typedef int ARRAY [255];
typedef int FUNC (int, int);
```

以上：

- 第一行是将标识符DWORD定义为int类型的别名；
- 第二行是将标识符`dWord`定义为`DWORD`类型的别名，实际上也是`int`的别名；
- 第三行是将标识符`PCHAR`定义为`char *` 类型的别名；
- 第四行是将标识符`ARRAY` 定义为数组类型`int [255]`的别名；
- 第五行是将标识符`FUNC`定义为函数类型`int (int,int)`的别名；

下面将用这些类型声明变量和函数：

```c
DWORD x; // int x;
ARRAY a,b [20]; // a[255], b [20] [255]
FUNC f;
```

#### 声明临时数组、激活使用、结束使用

类型`va_list`是在头文件`<stdarg.h>`中定义。在不同的C实现上定义不同，但我们包含并使用它即可。

`va_start` 是一个宏，也是在头文件`<stdarg.h>`中定义的，用来指使`ap`指向变参函数中最后一个已知参数（从右往左数的第一个已知参数），从而为访问后面的变参做准备。该宏具有两个参数，第一个参数是那个被声明为`va_list`类型的变量；第二个参数则是标识符，它必须是变参函数中最后那个已知参数的名字；

```c
long long int sum_ints 
    (unsigned int count, ...){
    /*...*/
    va_list ap;
    va_start(ap, count);
    while (count --) sum += va_arg(ap, int);
    va_end(ap);
    /*...*/
}
```

为了获得变参的值，这里使用了另一个宏`va_arg`，它同样是在头文件`<stdarg.h>`中定义的。该宏具有两个参数，第一个参数被声明为`va_list`类型的变量；第二个参数则是类型名；在程序翻译时，这个宏会被拓展为一个表达式，所以它可以直接作为运算符`+=`的右操作数；

```c
sum += va_arg(ap, int);
```

一开始，我们令`va_list`类型的变量`ap`指向最后一个已知参数。此后，每调用一次`va_arg`，都会使`ap`指向下一个参数（变参）并取得（计算出）它的值。

```c
va_end(ap);
```

最后，宏`va_end`将修改变量`ap`使它不再可用，它同样是在头文件`<stdarg.h>`中定义的。如果一个函数里曾使用`va_start`引用过变参，则它必须调用`va_end`才能保证返回时一切正常。如果没有，则行为是未定义的；

回到开头，定义了一个类型`VARF`

```c
typedef long long int VARF (unsigned int, ...);
```

如果没有关键字`typedef` 这是声明了一个函数`VARF`因为有关键字`typedef` 这是将标识符`VARF`定义为它被声明的类型，即，将函数`VARF` 定义为函数类型`long long int`。也就是说，`VARF` 现在是一种函数类型的名字，别名；

```c
VARF sum_ints;
// 等价于
// long long int sum_ints(unsigned int,)
```

#### Checkpoint6.4

1. 如果F是“指向‘有两个int类型的参数且返回类型是int的函数’的指针”的别名，请问F是如何定义的？编写一个程序，用类型F声明一个指向函数的指针，并用这个指针调用它所指向的函数。

```c
typedef int F (int, int);
```

```c
typedef int F(int, int);
int main(void){
    F func;
    int res = func(1,2);
}
int func(int a, int b){
    return a + b;
}
```



2. 在下面的程序里，函数`var sum`是个变参函数。参数`fmt`用于接受一个字符串，字符串的内容用于指示对应的变参的类型。比如，“1”表示对应的变参是longint类型；“i”表示对应的变参是int类型；“I”表示对应的变参是指向int的指针；“L”表示对应的变参是指向1 ong int的指针。
   - 函数var sum的任务是依据参数fmt来取得各个变参的值，或者，变参是指针的，取得它所指向的变量的值，然后返回累加的结果。
   - 在main函数里，我们调用了var sum函数，传入的字符串是“1IiiL”,后面的5个参数对应于这个字符串的指示。
     现在，请将函数var sum补充完整，并在你的机器上翻译和调试，以检验自己写的是否正确。

```c
# include <stdarg.h>
int var_sum(char * fmt, ...){
    // fill in
}

int main(void){
    int x = 50, r;
    long int y = 3;
    r = vs_sum("lIiiL", 5L, & x, 6, 7, & y);
}
```

### 认识逐位或、逐位与和逐位异或运算符

开头引入的一些都是POSIX标准的头文件，可以在头文件包含指令中使用路径。

```c
/**********************c0608.c*********************/
# include <unistd.h>
# include <fcntl.h>
# include <sys/stat.h>

int main (void)
{
    int fd;
    fd = open ("myfile1.dat", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);

    if (fd == -1) return -1;
    /*...*/
}
```

open函数在`<fcntl.h>`中的声明：

```c
int open(const char * pathname, int oflag, ...);
```

在打开文件的语句中：

```c
    fd = open ("myfile1.dat", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
```

- 因为`pathname`被声明为`const`，所以可以直接使用字面串；
- `O_CREAT` 、 `O_RDWR` 这些是操作的关键字：
  - 首先这些关键字在特定的位上是1，如：`0001` `0010`；
  - 通过`|` 或操作符可以把两个关键字的结果综合起来，最后形成了一个复合的选项定义；`0011`

- 函数`open`返回了一个整数唯一地代表这个文件，叫作文件描述符或者文件句柄。如-1则打开失败；

### 指向void的指针

开始向文件中写入内容

```c
    char name [] = "LiuChangjiang", gender = 'M', age = 36;
    unsigned int score = 2200;

    write (fd, name, strlen (name));
    write (fd, & gender, sizeof gender);
    write (fd, & age, sizeof age);
    write (fd, & score, sizeof score);

    close (fd);
```

函数`write`的定义如下：

```c
ssize_t write (int filedes, const void * buff, size_t nbytes);
```

- 第一个参数`filedes`的类型是`int`，用于指定一个文件描述符；第二个参数`buff` 用于指向一个缓冲区；

> 缓冲区是一个连续的内存空间，比如：数组。可以起到缓存的作用；

- 第二个参数`buff` 被声明为一个指向`const void` 类型的指针以适应传入的各种指针类型；

> void 表示没有参数，或者说参数为空；如果函数的返回类型是void，表示不返回任何值；所以不能`void v`这样定义变量。由于指向`void`类型的指针不能用于访问它所指向的变量，因为无法知道变量的大小。也不能加减操作，因为不知道长度；
>
> 因此，只能将用户指定的变量区转化为(char *)类型，因为char只有一个字节，故可对齐所有类型；

- 第三个参数`nbytes` 是要写入的字节数，它会返回实际写入的字节数；如果错误则为-1；

> 在一个语句写入完成后，函数会自动移动在文件中的指针，如果想要手动移动也可以；

- `strlen` 函数用于计算除了`'\0'` 之外的数组真实长度；
- `close` 用于关闭文件流；

>上述文件编译时不需要指定库文件，gcc会链接大部分标准库文件

```c
ssize_t read (int filedes, void * buff, size_t nbytes);
```



### 结构类型

C语言中，从基本类型构建其他类型称为 **类型的派生** ，指针、数组和函数都是派生类型。

> 按理说，类型应该先派生再使用，但指针、数组和函数类型的派生过程是与变量或者函数声明合二为一的，换句话说，在C语言中不存在指针、数组和函数指定符，在声明后才会产生具体的数组、指针和函数类型，无法事先定义；

使用 **结构类型** 声明类型指定符，语法为：

```c
struct 标识符 (可选) {成员声明列表}
struct 标识符
```

如：

```c
struct {
    int x;
    int y;
}
```

结构类型可以用来声明变量和函数，如：声明类型为`struct (int x, int y;)` 类型的`crd`

```c
struct {int x, int y;} crd;
```

#### 结构类型指示符的唯一性

在下面例子中，我们认为`m` 与 `n` 相同：

```c
int m;
int n;
```

但一下两个变量类型不同：

```c
struct {char name[20]; int chy} person1;
struct {char name[20]; int chy} person2;
```

结构类型指定符虽然也是类型指定符，但它毕竟不是内置类型，而是派生类型，所以每个出现在程序中的类型指定符具有自我声明的性质。换句话说，它虽然是一个类型指定符，但他同时一种新的结构类型声明。 **带有成员变量声明列表的结构指定符每出现一次，都将声明一个新的结构类型**。

所以，结构类型指定符中的标识符通常不该省略，这个标识符称为类型的唯一标记，以下这两个类型才是相同的：

```c
struct person {char name[20]; int chy} person1;
struct person person2;
// 事实上，我们可以先声明标记，再用标记声明变量：
struct person person3, * person4;
```

当然，也可以用`typedef` 一次性声明多个类型变量；

```c
typedef struct {
    char name [20];
    int char;
    int chk;
} sPersn, persn;
```

#### 使用初始化器

```c
struct persn person1 = {{"haha"},'M',33}
```

- 初始化器中的`{}`是可选的，用于初始化第一个变量；
- 如果初始化器的数量少于结构成员的数量，则初始化器的顺序依然按照结构成员声明的顺序进行，多余的成员会被初始化为默认值，如果是整型，则会被初始化为0，如果是指针，则是空指针；

```c
struct persn person2 = {.chk = 33,}
```

- 数组的初始化器中可以使用`[]`来指示一个要初始化的数组元素，在结构类型中，**可用`.` + 成员变量名不考虑顺序地指示初始值**

![image-20220825004104032](https://cdn.notcloud.net/static/md/cy948/202208250041083.png)

- 因为对齐的缘故，中间会存在空余的字节。是否会有填充的字节取决于结构成员的类型和数量。填充的字节内容是不确定的，通常是一些随机值；



下面程序用于向显示器输出一个字符的内容

```c
/*********************c0610.c********************/
# include <unistd.h>

int main (void)
{
    char * pbook = "The Laws of Boole's Thought.\n";
    write (STDOUT_FILENO, pbook, strlen (pbook));
}
```

> 每个运行在OS上的程序都会有一段初始化的代码。这个初始化的过程包括打开三个标准设备：标准输入、标准输出和标准错误。
>
> - 标准输入通常指硬盘，供每个程序获取外部输入；
> - 标准输出通常指显示器，供每个程序输出信息；
> - 标准错误通常指显示器，供每个程序输出它的错误信息；
>
> 这三个设备都被当成文件对待，所以它们的文件描述符分别是0、1、2；不需要希纳是地打开或创建，它们的预定义的；在程序开始时已经打开了；

如需将标准输入、输出、错误的结果定位到其他设备和文件可以使用“管道符”`>`，如：

```sh
./c.out > dest.txt
cat dest.txt

# content
```

于是运行结果并不在屏幕显示，而是创建并写入了文件dest.txt

p217...
