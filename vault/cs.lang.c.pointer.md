---
id: knf383ffka46dw9ydbi9si7
title: 指针
desc: ''
updated: 1659538606191
created: 1659502436026
---

# 指针

## C语言规定

- 一元 `*` 运算符的操作数必须是一个 `指针` 。 

如果不是指针，无法寻址或不指定寻址变量的类型，是无意义的。

- 如果操作数是指向某变量的指针， 则一元 `*` 运算符的结果是个 `左值` ，代表那个变量；

例如语句： `int * p = 0;` 中 `p` 为指向 `int` 类型的指针，当需要为 `p` 指向的值进行赋值时，会使用 `* p = 1` 这样的语句， `* p` 代表了该变量的位置，不执行左值转化，不会出现`0 = 1` 把0赋值1的情况；

- 如果操作数是指向函数的指针， 则一元 `*` 运算符的结果是函数指示符，代表那个函数

在下面例子中， 使用新的指针pf指向swap所指向的函数；


![](https://cdn.notcloud.net/static/md/cy948/202208031335318.png)

```c
char * swap(char * a, char * b){
    char tmp = * a;
    * a = * b;
    * b = tmp;
    return * a > * b? a : b;
}

int main(void){
    char (* pf) (char *,char *) = swap;
}
```

## `* E` 是合法的表达式，表达式结果不可能是 `值`

[[cs.lang.c.1-const#值是计算机操作和加工的对象]]

- 表达式会进行逻辑运算，每个表达式都可以计算出 `值` ，但因为 `* E` 表达式作为一个整体，本身不进行计算，所以不能得出 `值` 

[[cs.lang.c.1-const#左值和左值转换]]

- 结果是一个带有类型的值(变量)；

- 如果 `* E` 在 `=` 左边，则 `* E` 是左值；

## 类型

### ul后缀

后缀 `u` 或者 `U` 是 `unsigned` 的意思，后缀 `l` 或者 `L` 是 `long` 的意思； 后缀 `ll` 或者 `LL` 是 “long long” 的意思。这几种后缀可以单独使用或组合使用，但只能 `ll` or `LL`，不能 `lL`。`ull` `uLL` 都可以。

### 进制

- 十进制：以非0数字开头；

- 八进制：以数字0开头；

- 十六进制：以 `0x` 开头；

### 转型

分为三种情况： 目标类型为 `_Bool` 、可以用转换后的新类型表示、不可以用转换后的新类型表示

- `_Bool` C99开始，任何整数类型的值转换为 `_Bool` 时，零值转换为 `0` ，非零值转换为 `1` ；

- 如果一个整数类型的值转换为除 `_Bool` 以外的整数类型时，如果这个值可以用新类型表示，则转换后的值同原值不变；

- 如果不可以：
    - 目标类型为 `无符号整数` ：会将该值重复 **加上** 或 **减去** 比新类型所能表示最大值大1的数；
    - 目标类型为 `有符号的整数`：取决于C实现。

如： 

`unsigned char` 类型所黁给表示的最大值是 `255`， 所以将 `3700` 赋值时会用 `3700` 不断减去 `256` 直到结果小于或者等于 `255` 。

某无符号整数类型可表示的最大值为 `M` ，那么， 把 `-1` 赋给这种类型的变量后， 该变量的值是 `-1 + (M+1) = M`;

### 整型转换阶和整型提升

- **只在原有的类型** 上操作，例如前缀递增运算符和后缀递增运算符，他们不要求改变操作数的类型。再比如赋值运算符，它不要改变左操作数的类型，而是要求右操作数必须转换为左操作数的类型。

- **不在原来的类型** 上操作，例如：

```c
int main(void){
    signed char cx = 1, cy = 2;
    signed long int sl = 0;
    unsigned long int ul = 0;

    sl += cx + cy;
    sl += cx * 3L;
    ul += sl <= ul;

    unsigned char uc = -1;
    cy = - uc ++;
}
```

在表达式 `sl += cx + cy` 中，虽然 `cx` 和 `cy` 的类型为 `signed char` ,但计算时需要进行整型转换再相加。
