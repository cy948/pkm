---
id: iz9f7qg6rjn99fvkjhxiwgv
title: 06 图
desc: ''
updated: 1665809181576
created: 1665485620254
---



# 图

> 图的难度较大，相关算法较多，通常只要求掌握其基本思想和实现步骤，具体实现不是重点。

## 图的基本概念

### 定义

> 图是一种多对多的逻辑结构，以下定义可以先过一遍，然后结合下面的例子进行理解。

图由顶点集 $V$ 和边集 $E$ 组成，记为$G=(V,E)$，其中$V(G)$表示图$G$中顶点之间的关系（边）集合。若$V=\{v_1,v_2,...,v_n\}$，则用$|V|$表示图$G$中顶点的个数，$E=\{(u,v)|u\in V,v\in V\}$，用$|E|$表示图$G$中边的条数。

> ⚡顶点是指图中的一个点，图上每个点都可以称为顶点。
>
> ❗线性表可以是空表，树可以是空树，但图不可以是空图。图的顶点集不可以为空，边集可以为空。

#### 有向图、无向图

> 根据图去了解表示方法

如图所示，有向图的边是有向的，无向图的边是无向的。

 ^85q5r5yu3in5
![image-20221011191318460](https://cdn.notcloud.net/static/md/cy948/202210111913490.png)

 ^k9scbhk8m78h

- 有向图：

若 *E* 是有向边（也称 弧）的有限集合时，则图 *G* 为有向图。 **弧**是顶点是**有序对**，记为$<v,w>$，其中 *v,w* 是顶点， *v* 称为**弧尾**， *w* 称为**弧头**，$<v,w>$ 称为从 *v* 到 *w* 的弧，也称 *v* 邻接到 *w* ，由 **弧尾** 指向 **弧头**。
$$
G_1=(V_1,E_1) \\
V_1=\{ 1,2,3 \} \\
E_1 = \{ <1,2>,<2,1>,<2,3>\}
$$

- 无向图：

若 *E* 是无向边（简称 边）的有限集合时，则图 *G* 为无向图。边是顶点的无序对，记为 *(v,w)* 或 *(v,w)* （因为无序，反过来记也一样）。可以说 *v* 和 *w* 互为邻接点。 边 *(v,w)* 依附于 *w* 和 *v* ，或称边 *(v,w)* 和 *v,w* 相关联。
$$
G_2=(V_2,E_2) \\
V_2=\{ 1,2,3 \} \\
E_2 = \{ (1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\}
$$

#### 简单图、多重图

简单图满足：

- 不存在重复边；
- c；

> 如下图 $G_1,G_2$ 

多重图：

- 某两个顶点之间的边数大于 *1* 条；
- 又允许通过一条边与自身关联；

> 🤷‍♂️多重图和简单图是相对的，数据结构中仅讨论**简单图**



![[degree.master.c.06-图#^85q5r5yu3in5:#^k9scbhk8m78h]]

#### 完全图 （简单完全图）

> 以下的 “无向图” 均为 “简单无向图”
>
> $|E|$  代表（边取值范围）

无向图的 $|E|$ 是 $[0,n(n-1)/2]$ ，拥有最大边数量：*n(n-1)/2* 的无向图称为完全图，在完全图中任意两个顶点之间都存在 **边**。

有无向图的 $|E|$ 是 $[0,n(n-1)]$ ，拥有最大边数量：*n(n-1)* 的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在相反的 **弧**。

> 下图中 *G2* 为无向完全图， *G3* 为有向完全图

![[degree.master.c.06-图#^85q5r5yu3in5:#^k9scbhk8m78h]]

🤔最大边数量是怎么来的？

首先，图 *G* 是一个简单图，需要符合简单图的特征：

- 不存在重复边；
- 不存在顶点到自身的边；

在**无向图**中，根据每个点都与除自己之外的点进行 *关联* ，即 组合 *Combination*，即： 从 *n* 个中选取 *2* 个进行组合：
$$
C(n,2) = \frac{n!}{(n-2)!*2!} \\
= \frac{n(n-1)}{2}
$$
在 **有向图** 中，因为具有方向，所以是：从 *n* 个中选取 *2* 个进行 排列 *Permutation* ，即：从 *n* 个中按顺序选取 *2* 个进行排列：
$$
A(n,2) = \frac{n!}{(n-2)!} \\
= n(n-1)
$$


#### 子图、生成子图

设有两个图 $G=(V,E) \ G' = (V',E')$，若 $V'$是 *V*  的子集、$E'$  是 *E* 的子集，则称 $G'$ 为 *G* 的子图；

在此基础上，若满足 $V(G') = V(G)$ ，则称 $G'$ 为 *G* 的生成子图；

> ❗并非 *V* 和 *E* 的任何子集都能构成 *G* 的子图，因为这样的子集有可能不是图。*E'* 中某些边的顶点可能不在 *V'* 中。



#### 连通、连通图和连通分量 （无向图）

在 **无向图** 中，若从顶点 *v* 到顶点 *w* 有路径存在，则称 *v* 和 *w* 是连通的。 

> ❗连通可以不直接相 **关联**，能通过别的顶点到达顶点的都是连通的。

- 若图 *G* 中任意两个顶点都是连通的，则称图 *G* 为**连通图** ，否则为 **非连通图**；
- 如下图：无向图中的 *极大连通子图*[^极大子图] 称为 **连通分量**；

![image-20221011201207581](https://cdn.notcloud.net/static/md/cy948/202210112012615.png)

> 🤔 假设一个图有 *n*个顶点， 如果边数小于 *n - 1* ，那么此图一定是不连通的（*n-1* 条边意味着每个顶点之间只存在唯一路径）。那非连通图最多可以有多少条边呢？

要想达到最大边数，可以恰好令其中 *n - 1* 个点是完全图，此时再增加一条边就是连通图了。此时边的数量关系是：
$$
|E'| = \frac{(n-1)(n-2)}{2} \\
|E| = |E'| + 1
$$

[^极大子图]: 从图 6.2 中可直观地看出：极大子图就是一些相互连通的顶点能组成的边数最大的连通子图

#### 强连通图、强连通分量 （有向图）

在 **有向图** 中，若从顶点 *v* 到顶点 *w* 和 顶点 *w* 到顶点 *v* 均有路径存在，则称 *v* 和 *w* 是 **强连通** 的。

>  ❗连通可以不直接相 **邻接**，能通过别的顶点到达顶点的都是连通的。

- 若图中任意一对顶点都是 *强连通* 的，则称此图为 **强连通图**；
- 有向图中的*极大强连通子图* 称为有向图的 **强连通分量**，

![image-20221011210325551](https://cdn.notcloud.net/static/md/cy948/202210112103579.png)

🤔假设一个有向图有 *n* 个顶点，如果是强连通图，那么最少需要多少条边？

只需要 *n* 条边构成一个环路即可。

> ❗在无向图中讨论连通性，在有向图中讨论强连通性；

#### 生成树、生成森林

连通图的生成树是包含图中全部顶点的一个*极小连通子图*  [^极小子图] 。若图中定点数为 *n* ，则它的生成树含有 *n* 条边。包含图中全部顶点的 *极小连通子图*， 只有生成树满足这个 *极小* 条件，对生成树而言：

- 砍去它的一条边，则会变成*非连通图* ；
- 若加上一条边则会形成一条回路；
- 在非连通图中，*非连通分量* 的生成树构成了*非连通图* 的生成森林；

![[degree.master.c.06-图#^85q5r5yu3in5:#^k9scbhk8m78h]]

> ❗注意区分*极大连通子图* 和 *极小连通子图* 。*极大联通子图* 是 **无向图** 的连通分量，*极大* 即要求该连通子图包含其所有的边；*极小连通子图* 是既要保持图连通又要使得边数最小的子图。


[^极小子图]: 从图 6.4 中可直观地看出：极小子图就是一些相互连通的顶点能组成的边数最少的连通子图



#### 顶点的度、入度和出度

在 **无向图** 中，顶点 *v* 的度(Degree)是指依附于顶点 *v* 的边的条数，记为 *TD(v)* 。在下图(b)中，每个顶点的度均为 *3* 。对于具有 *n* 个顶点、*e* 条边的无向图：
$$
\sum_{i=1}^{n} TD(v_i)=2e
$$

> 😯 无向图的<ul>全部顶点</ul>的 *度* 的和等于 *边数* 的 *2* 倍，因为 *每条边* 和 *2* 个 *顶点* 相关联。

![[degree.master.c.06-图#^85q5r5yu3in5:#^k9scbhk8m78h]]

在 **有向图** 中，顶点 *v* 的 *度* 分为 *入度* 和 *出度* ，*入度* 是以顶点 *v* 为 **终点** 的有向边的数目，记为 *ID(v)* ；而出度是以顶点 *v* 为 **起点** 的有向边的数目，记为 *OD(v)* 。在上图(a)中，顶点 *2* 的出度为 *2* 、入度为 *1* 。顶点 *v* 的度等于其 *出度* 和 *入度* 的和，即 *TD(v) = ID(v) + OD(v)* 。对于具有 *n* 个顶点、*e* 条边的有向图：
$$
\sum_{i=1}^{n}ID(v_i)=\sum_{i=1}^{n}OD(v_i)=e
$$

> 😯 有向图的<ul>全部顶点</ul>的 *入度* 之和等于*出度* 之和，等于 *边数* ，这是因为每条有向边都有一个起点和终点。

#### 边的权和网

在一个图中，每一条边都可以标上具有某种含义的数值，该数值称为该边的 *权值* 。这种边上带 *权值* 的图称为 *带权图*，也称网。 



#### 稠密图、稀疏图

边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身就是模糊的概念，是相对而言的。

> 一般当图满足 $|E|<|V| \ \log|V|$ 时可视为稠密图



#### 路径、路径长度

顶点 $V_p$ 到顶点 $V_q$ 之间的一条 *路径* 是指 **顶点序列**  $v_p,v_1,v_2,...,v_{i_{m}},v_q$ ，当然关联的边也可以理解为路径的构成要素。路径上边的数目称为 *路径长度* 。

- 第一个顶点和最后一个顶点相同的路径称为 *回路* 或 *环* 。
- 若一个图有 *n* 个顶点，并且有 *n-1* 条边，则此图一定有 *环* ；

> *n - 1* 条边意味着每个顶点可以分到不少于 *1* 条边，因此当边 $|V|> n-1$ 条边的时，至少有一个顶点分到 $\ge 2$ 条边，因为是简单图，不能联接自己， 就形成了环。



#### 简单路径、简单回路

在路径序列中，顶点 **不重复** 出现的路径称为 *简单路径* 。除第一个顶点和最后一个顶点外，其余顶点 **不重复** 出现的回路称为 *简单回路* 。



#### 距离

从顶点 *u* 出发到顶点 *v* 的最短路径存在，则此路径的长度称为从 *u* 到 *v* 的 *距离* 。

若从顶点 *u* 出发到顶点 *v* 不存在路径 ，则标记该路径长度为无穷 $\infty$ ；



#### 有向树

一个顶点的入度为 *0* 、其余顶点的入度均为 *1* 的有向图称为 *有向树*。

> 🤔 入度均为 *1* ，每个 *顶点* 只有一个前继，这不就是树吗？



### 试一试



## 图的存储及基本操作

> 图的存储必须要完整、准确地反映顶点集和边集的信息。 根据不同的结构和算法，采用不同的存储方式对程序的效率产生相当大的影响，因此 **所选的存储结构应该适合求解问题**。

### 邻接矩阵法

#### 表示方法

用一个一维数组存储 *顶点* 信息，二维数组存储 *边* 的信息（各点之间的邻接关系），存储顶点之间 *邻接关系* 的**二维数组**叫做 *邻接矩阵* 。

顶点数为 *n* 的图 $G=(V,E)$ 的邻接矩阵 *A* 是 *n \* n* 的。将各顶点编号为 $v_1,v_2,...,v_n$ 。

**不带权**：若 $(v_i,v_j) \in E$ ，即两顶点 *邻接* ，则 c，否则 *A\[i\]\[j\] = 0*。
$$
\begin{equation}
A[i][j]=
\begin{cases}
1,& \text{若} (v_i,v_j) \text{或}<v_ i,v_j> \ \text{是}E(G)\text{中的边}\\
0,& \text{若} (v_i,v_j) \text{或}<v_i,v_j> \ \text{不是}E(G)\text{中的边}
\end{cases}
\end{equation}
$$
**带权**：若顶点 *邻接* ，则 *A\[i\]\[j\]* 中存放着该边对应的权值，若顶点 $V_i,V_j$ 不邻接，则用 $\infty$ 或 *0* 表述两个顶点之间不存在的边。
$$
\begin{equation}
A[i][j]=
\begin{cases}
w_{ij},& \text{若} (v_i,v_j) \text{或}<v_ i,v_j> \ \text{是}E(G)\text{中的边}\\
0 \ \text{或} \infty ,& \text{若} (v_i,v_j) \text{或}<v_i,v_j> \ \text{不是}E(G)\text{中的边}
\end{cases}
\end{equation}
$$
> 一般情况下，二维数组使用列优先存储， *i* 是行 *j* 是列；
>
> ![[degree.master.c.03-栈、队列和数组#二维数组:#^ey83614twvnw]]
>
> 

图的邻接矩阵存储结构定义如下：[^varsnaming]

```c
#define MaxVertexNum 100 // 顶点数目的最大值
typedef char VertexType; // 顶点的数据类型
typedef int EdgeType; // 带权图中边上权值的数据类型
typedef struct {
    VertexType Vex [MaxVertexNum]; // 顶点表Vex
    EdgeType Edge [MaxVertexNum][MaxVertexNum]; // 邻接矩阵，边表
    int vexnum, arcnum; // 图的当前顶点和弧数
} MGraph;
```

![image-20221014193542269](https://cdn.notcloud.net/static/md/cy948/202210141935305.png)

[^varsnaming]: 关于变量命名，顶点相关用 *Vertices*，和边、弧相关的用 *Edges*，结点 *Node* ；

#### 特点

❗注意：

- 在简单应用中，可直接使用二维数组作为图的邻接矩阵（顶点信息均可省略）；
- 当邻接矩阵的元素仅表示相应边是否存在的时候，`EdgeType` 可采用值 *0* 或 *1* 的枚举类型 [^enumtype]；
- 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储；
- 邻接矩阵表示法的空间复杂度固定为 $O(n^2)$ ，其中 *n* 为图的顶点数 *|V|* ；

[^enumtype]: 泛指取值的个数是有限的，每个取值都有指定含义，或者参考文档查看含义及使用方法 [Enumeration (or enum) in C - GeeksforGeeks](https://www.geeksforgeeks.org/enumeration-enum-c/)

图的邻接矩阵表示法具有以下**特点**：

- 无向图的邻接矩阵一定是一个 *对称矩阵（并且唯一）* 。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素，也成为 *压缩* ；

- 无向图邻接矩阵的第 *i* 行（或第 *i* 列）非零元素（或非 $\infty$ 元素）的个数正好是顶点 *i* 的度 $TD(v_i)$ ；

- 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，**要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大**；

- **稠密图**适合使用邻接矩阵的存储表示；

> 补充：设图 *G* 的邻接矩阵为 $A$ ， $A^n$ 的元素 $A^n[ i ][ j ]$ 等于由顶点 *i* 到顶点 *j* 的长度为 *n* 的路径的数目[^matrixn]；

[^matrixn]: 仅供参考 [如何直观理解邻接矩阵的 k 次幂可以表示长度为 k 的有向路数目？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/360206722)

🅿️此处考点很多，需要动手画一画。

### 邻接表法

> 上述提到 “ *稠密图* 适合使用邻接矩阵的存储表示”，如为 *稀疏图* 则适合使用 **邻接表法** 存储。

#### 表示方法

对图 *G* 中每个顶点 $v_i$ 建立一个单链表， 第 *i* 个单链表中的结点表示依附于顶点 $v_i$ 的边（对于有向图则是以顶点 $v_i$ 为尾的弧），这个单链表就称为顶点 $v_i$ 的边表（对于有向图则成为出边表）。

边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：*顶点表结点* 和 *边表结点* ，结构如图6.6 所示：

![image-20221014201000149](https://cdn.notcloud.net/static/md/cy948/202210142010187.png)

*顶点表结点* 由 `顶点域（data）` 和指向下一条邻接边的 `指针（firstarc）` 构成，*边表（邻接表）结点* 由 `邻接点域（adjvex）` 和指向下一条邻接边的 `指针域（nextarc）` 构成。以下为示例：

> 🅿️ 此处停下来用邻接表法尝试表示图

![image-20221014201321700](https://cdn.notcloud.net/static/md/cy948/202210142013756.png)



图的邻接表存储结构定义如下：

```c
#define MaxVertexNum 100 // 顶点数目的最大值
// 边表结点
typedef struct ArcNode{
    int adjvex; // 该弧所指向顶点的位置
    struct ArcNode * next; // 指向下一条弧的指针
    // InfoType info; // 结点信息，可用于存放网的边权值
} ArcNode;
// 顶点表结点
typedef struct VNode{
    VertexType data;
    ArcNode * first;
} VNode;
// 邻接表
typedef struct {
    VNode vertices [MaxVertexNum]; // 邻接表
    int vexnum, arcnum; // 顶点和弧数
} ALGraph;
```

#### 特点

图的邻接表存储方法具有以下**特点**：

- 若 *G* 为 **无向图** ，则所需的存储空间为 $O( |V| + 2|E| )$ ；若 *G* 为有向图，则所需的存储空间为 $O(|V| + |E|)$ 。前者的倍数 *2* 是由于无向图中，每条边在 *邻接表* 中出现了两次；
- 对于 **稀疏图**，采用 *邻接表* 表示将极大地节省存储空间；
- 在 *邻接表* 中，给定一顶点，就很容易地找出它的所有邻边，因为只需要读取它的 *邻接表* ；
  - 在 *邻接矩阵* 中，相同的操作需要扫描一行，花费的时间为 *O(n)* ；
  - 但如果想确定两个顶点之间是否存在边：
    - *邻接矩阵* 可以直接读取下标得到；
    - 而 *邻接表* 则需要在 结点对应的边表中查找另一个结点，效率较低；

- 在 **有向图** 的 *邻接表* 表示中，求一个给定顶点的 *出度* 只需要计算其邻接表中的结点个数；但求其顶点的 *入度* 则需要遍历全部的邻接表；因此也有 *逆邻接表法* 的存储方式快速求解顶点的 *入度* ，这种方法的方式与本操作相反，但求 *出度* 复杂；
- 图的 *邻接表* 表示并 **不唯一**，因为每个顶点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表算法及边的输入顺序；



### 十字链表（有向图only）

#### 表示方法

*十字链表* 是 *有向图* 的一种链式存储结构。在 *十字链表* 中，对应于有向图的每条弧由一个结点，对应于每个顶点，对应于每个顶点也有一个结点。这些结点的结构如下图所示：

<img src="https://cdn.notcloud.net/static/md/cy948/202210142056235.png" alt="image-20221014205659196" style="zoom:67%;" />

*弧结点* ：

- `tailvex` 和 `headvex` ： 尾域，头域。指示弧尾和弧头这两个顶点在图中的位置；
- `hlink` ：指向弧头相同的下一条弧；
- `tlink` ：指向弧尾相同的下一条弧；
- `info` ：指向该弧的相关信息；

*顶点结点*：

- `data` ：存放顶点相关的数据信息，如顶点名称；
- `firstin` 和 `firstout` ：分别指向以该顶点为弧头或弧尾的第一个弧结点；

示例：

> ❗*顶点结点* 是顺序存储的

<img src="https://cdn.notcloud.net/static/md/cy948/202210142104018.png" alt="image-20221014210450969" style="zoom:80%;" />

#### 特点

- 容易找到以 $V_i$ 为尾的弧，又容易找到 $V_i$ 为头的弧，因而容易求出顶点的 *出度* 和 *入度* ；
- 图的十字链表示法不是唯一的，但一个十字链表表示确定一个图；

> 此处非常不容易理解，建议打开[processon](https://www.processon.com/)选择流程图，然后[从模板创建](https://www.processon.com/view/634963ec7d9c080c425735fb?fromnew=1)

<details>
    <summary>查看流程大图</summary>
    <iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:525px; height:245px;" src="https://www.processon.com/embed/634963ec7d9c080c425735fb"></iframe>
</details>

- 遍历每个结点，对于每个结点：

  - 为出度建立结点；

  ![image-20221014222418114](https://cdn.notcloud.net/static/md/cy948/202210142224181.png)

  - 为入度连接已有结点；

  ![image-20221014222442045](https://cdn.notcloud.net/static/md/cy948/202210142224108.png)

  

### 邻接多重表（无向图only）

> 是 *无向图* 的另一种链式存储结构；

🤔在邻接表中，容易求得顶点和边的各种信息，但在 *邻接表* 中求两个顶点之间是否存在边而对边进行删除/更新等操作时，需要分别在两个顶点的边表中遍历，效率较低。

#### 表示方法

与 *十字链表* 相似，在 *邻接多重表* 中，每条边用一个结点表示，其结构如下：

![image-20221015111210112](https://cdn.notcloud.net/static/md/cy948/202210151112156.png)

- `mark` 标志域：可以用来标记该边是否被搜索过；
- `ivex` 和 `jvex` 为该边依附的两个顶点在图中的位置；
- `ilink` 指向第一条依附于顶点 `ivex` 的边；
- `jlink` 指向第一条依附于顶点 `jvex` 的边；
- `info` 指向和边相关的各种信息的指针域；

每个顶点也用一个结点表示，它由如下所示的两个域组成。

![image-20221015112257388](https://cdn.notcloud.net/static/md/cy948/202210151122429.png)

- `data` 存储该顶点的相关信息；

- `firstedge` 域指示第一条依附于该顶点的边；

在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点在图中的位置，因此每个边结点2可以同时链接在两个链表中。对于无向图而言，其邻接多重表和邻接表的差别仅在于：同一条边在邻接表中用两个结点表示，而在邻接多重表只有一个结点。



![image-20221015124912595](https://cdn.notcloud.net/static/md/cy948/202210151249654.png)

> 此处同样建议使用所提供[模板]()进行练习
#### 特点

- 快速找到边并对边进行操作；



### 基本操作

图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能，设计具体算法时应考虑效率；

图的基本操作主要包括（抽象考虑，忽略类型的ADT[^adt]定义）：

- `CreateGraph(&G, V, E)` ：从顶点集 *V* 和 边集 *E* 中为图 *G* 创建图；
- `DeatroyGraph(&G)` ：销毁图 *G* ；
- `Adjacent(&G, x, y)` ：判断 *G* 是否存在边 *<x,y>* 或 *(x,y)*；
- `Neighbors(&G,x)` ：列出图 *G* 中与结点 *x* 邻接的边；
- `InsertVertex(&G, x)` ：在图中插入顶点 *x* ；
- `DeleteVertex(&G, x)` ：在图中删除顶点 *x* ；
- `InsertEdge(&G, x, y)` ：若无向边 *(x,y)* 或有向边*<x,y>*不存在，则向图 *G* 添加该边；
- `DeleteEdge(&G, x, y)` ：若无向边 *(x,y)* 或有向边*<x,y>*存在，则从图 *G* 中删除该边；
- `FirstNeighbor(&G, x, y)` ：求图 *G* 中顶点 *y* 是顶点 *x* 的一个邻接点，若有则返回顶点号。若  *x* 没有邻接点或图中不存在 *x* ，则返回 *-1* ；
- `NextNeighbor(&G, x, y)` ： 假设图 *G* 顶点 *y* 是顶点 *x* 的一个邻接点，返回除 *y* 外顶点 *x* 的第一个邻接点的顶点号；若 *y* 是 *x* 的最后一个邻接点，则返回 *-1* ；
- `DFS(G, v)` 
- `BFS(G, v)` 



[^adt]:[Abstract Data Types - GeeksforGeeks](https://www.geeksforgeeks.org/abstract-data-types/)



## 图的遍历

