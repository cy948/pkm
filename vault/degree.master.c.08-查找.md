---
id: 5h3u6l58ih1869tk542w0dg
title: 08 查找
desc: '重点'
updated: 1668518347500
created: 1666927813676
---


命题重点。
- 对于散列表的构造、冲突处理过程、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。
- 对于折半查找，应该掌握折半查找的过程、构造判定树、分析平均长度等。
- B树和B+树是本章的难点，B树：要求掌握处插入、删除和查找的过程；B+树：理解概念和性质即可。

## 基本概念

**查找**。在数据集合中寻找满足指定条件的数据元素过程称为 *查找* 。*查找* 的结果一般分为两种：一是 *查找* 成功，即在数据集合中找到了满足条件的数据元素；二是 *查找失败* 。

**查找表（查找结构）**。用于查找的数据结构的集合称为 *查找表* ，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有 *4* 种：
1. 查询某个特定的数据元素是否在查找表中；
2. 检索满足条件的某个特定的数据元素的各种属性；
3. 在查找表中插入一个数据元素；
4. 从查找表中删除某个元素；

**静态查找表**。若一个查找表的操作只涉及上述操作 `1.` 和 `2.` ，则无需动态地修改查找表，此类查找表称为 *静态查找表* 。与此对应，需要动态地插入或删除的查找表称为 *动态查找表* 。适合 *静态查询表* 的查找方法有：顺序查找、折半查找、散列查找等；适合 *动态查找表* 的查找方法有 二叉排序树的查找、散列查找等。

**关键词**。数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如：一个学生的集合中，“学号”唯一地标识学生；

**平均查找长度**。在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义是：
$$
ASL = \sum^{n}_{i=1}P_iC_i
$$

> ASL(average search length)

*n* 是查找表的长度； $P_i$ 是查找第 *i* 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 $P_i=\frac{1}{n}$ ； $C_i$ 是找到的第 *i* 个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要指标。


## 顺序查找和折半查找

### 顺序查找

顺序查找又称 *线性查找* ，它对关键字和链表都是适用的。对于顺序表，可通过数组下标递增来扫描每个元素。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。

#### 一般线性表的顺序查找

```c
typedef struct {
    ElemType * elem; // 建表时从下标1开始，0留空
    int TableLen;
} SSTable;
int Search_Seq(SSTable ST, ElemType key){
    ST.elem[0] = key; // 见下文
    for(int i = ST.TableLen; ST.elem[i]; --i);
    return i;
}
```

`ST.elem[0]=key` 的作用：
- 从后往前遍历的过程中，可能没有一个元素 *= key* ；
- 遍历的语句遇到元素 *= key* 时退出；
- 将 *0* 号元素赋值为 *key* 可以使在整个过程中的一定能找到 *key* ，不至于循环无法终止导致数组越界

对于有 *n* 个元素的表，给定指 *key* 与表中第 *i* 个元素相等，即定位第 *i* 个元素时，需进行 *n-i+1* 次关键字的比较，即 $C_i=n-i+1$ 。查找成功时，顺序查找的平均长度为：

$$
ASL_{\text{成功}}=\sum^{n}_{i=1} P_i(n-i+1) \\
$$

当每个元素的查找概率相等，即 $P_i=1/n$ 时，

若查找**成功**有：
$$
ASL_{\text{成功}}=\sum^{n}_{i=1} P_i(n-i+1)=\frac{n+1}{2}
$$

> 想不起来就用推一下
> $$
> ASL_{\text{成功}}=\sum^{n}_{i=1} P_i(n-i+1)\\
> \sum^{n}_{i=1}\frac{n+1-i}{n} =\sum^{n}_{i=1} 1+\frac1n-\frac{i}n\\
> =\frac{2(n + 1)}2 - \frac{(1+n)n}{2n}=\frac{n+1}{2}
> $$


查找**不成功**时，与表中关键字的比较次数显然是 *n+1* 次，从而顺序查找不成功的平均查找长度为 $ASL_{\text{不成功}}=n+1$ 

**结论：**

- **缺点** 是当 *n* 比较大时，平均查找的长度较大，效率低；

- **优点** 是对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用。同时还需注意，对线性的链表只能进行顺序查找（因为其无法通过 *O(1)* 的事件访问某个元素）。
- 通常，查找表中的概率并不相等。**改进**： 若能预先得知每个记录的查找概率，则应对记录的查找概率进行排序，使表中的该路按查找概率由大至小重新排列。

#### 有序表的顺序查找

若在查找之间就知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低查找失败的平均查找长度；

假设表 *L* 是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为 *key*，当查找到第 *i* 个元素时，发现第 *i* 个元素关键字大于 *key*，这时就可以返回查找失败的信息。

使用判定树来描述有序线性表的查找过程。树中的圆形结点表示有序线性表中存在的元素；树中的矩形结点称为 **失败结点** （若有 *n* 个结点，则相应地有 *n+1* 个查找失败结点）。它描述的是不在集合中的点，若 *key* 处在描述的范围内，则查找不成功。

![image-20221103200407338](https://cdn.notcloud.net/static/md/cy948/202211032004383.png)

在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找指针一定走到了某个失败结点。这些失败和节点实际上是不存在的，查找不成功的平均查找长度在相等查找概率下为：
$$
ASL_{\text{不成功}}=\sum^{n}_{j=1}q_j(l_j-1)\\
=\frac{1+2+...+n+n}{n+1} = \frac n2+\frac{n}{n+1}
$$
$q_i$ 是到达第 *j* 个失败结点是概率，在相等查找概率的情形下，它为 $\frac{1}{n+1}$ ； $l_j$ 是第 *j* 个失败结点所在的层数。当 *n=6* 时， $ASL_{\text{不成功}} = 6/2 + 6/7 = 3.86$  ，比一般的顺序查找算法好一些。

> ❗有序线性表的顺序查找和后面折半查找的思想不同，且有序线性表的顺序查找的线性表可以是 *链式存储结构*；

### 折半/二分查找

> 仅适用于有序的顺序表

首先将给定值 *key* 与表中中间位置的元素进行比较：

- 若相等则查找成功，则返回该元素的存储位置；
- 若不等，则所需查找的元素一定位于中间元素以外的前半部分或后半部分；

🔁然后缩短范围，重复上述过程；

> ❗注意：
>
> - 初始化时，`low =1 ` ，`hight = ST.Length` 。这是因为 `ST.R[0]` 为 *key* ，并不是第一个元素；
> - 运算过程中，向下取整：`1 + 4 / 2 = 2` ；

```c
int Search_Bin(SSTable ST, KeyType key){ 
    //若找到，则函数值为该元素在表中的位置，否则为0
    low = 1; high = ST.length;

    while(low <= high) {
    // 如果左指针小于右指针，证明遍历已完成，但无法找到

        mid = low + (high - low) / 2;
        //防止整型溢出
        
        if(key == ST.R[mid].key) return mid; //匹配成功
        
        else if(key < ST.R[mid].key)  high = mid - 1; 
        //前往值更小的子表查找

        else low = mid + 1;  
        //前往值更大的子表查找
    }      
    return 0; //表中不存在待查元素
}
```

查看动画：[704. 二分查找 - 力扣（Leetcode）](https://leetcode.cn/problems/binary-search/solutions/6700/hua-jie-suan-fa-704-er-fen-cha-zhao-by-guanpengchn/#画解)，看完记得顺手A一下：

```c
int search(int* nums, int numsSize, int target){
    int left = 0, right = numsSize-1, mid;
    while(left <= right){
        mid = left + (right - left)/2;
        if(nums[mid] == target) return mid;
        if(nums[mid] > target){
            right = mid - 1;
            continue;
        }
        if(nums[mid] < target){
            left = mid + 1;
        }
    }
    return -1;
}
```

递归版：

```c
int search(int* nums, int numsSize, int target){
    return search_iterate(nums, 0, numsSize-1, target);
}
int search_iterate(int* nums, int left, int right, int target){
    if(left > right) return -1;
    int mid = left + (right - left)/2;
    if(nums[mid] == target) return mid;
    if(nums[mid] > target) return search_iterate(nums, left, mid -1, target);
    return search_iterate(nums, mid + 1, right, target);
}
```

#### 复杂度



<img src="https://cdn.notcloud.net/static/md/cy948/202211032101345.png" alt="image-20221103210110306" style="zoom:80%;" />

上图二分查找 *11* 个元素的 *判定树* 中：

- 查找成功时的查找长度是：从根节点到目的结点上的路径上的结点数；

> 含义：每个结点概率相等，从 *n* 个成功的结点中选一个，但带路径长度；
> $$
> ASL_{\text{成功}}=\frac{\sum^n_{j=1}j \ n_{j\text{成功}}}{n_{元素}} \\
> ASL_{\text{成功}}=(1*1+2*2+3*4+4*4)/11=3
> $$
> $n_{j\text{成功}}$ 表示 *j* 层上成功的结点数；
>
> $n_{\text{元素}}$ 表示所有待查找的元素数量；

- 查找不成功时的查找长度为从根节点到对应失败结点父结点的路径上的结点数；

> 含义：每个结点概率相等，从 *n+1* 个失败的结点中选一个，但带路径长度；
> $$
> ASL_{\text{失败}}= \frac{\sum^n_{j=1}(j-1) \ n_{j\text{失败}} }{n_{元素}+1} \\
> ASL_{\text{失败}}=((4-1)*4+(5-1)*8)/12=\frac{11}{3}
> $$
> $n_{j\text{成功}}$ 表示 *j* 层上成功的结点数；
>
> $n_{\text{元素}}$ 表示所有待查找的元素数量；
>
> ❗查找失败结点的 *ASL* 不是图中方形结点，而是方形结点的上一层结点数量（可重复）。


每个结点均大于其左结点值，且均小于其右子结点值。若有序序列有 *n* 个元素，则对应的判定树有 *n* 个圆形的非叶结点和 *n+1* 个方形的叶结点。显然，判定树是一颗 *平衡二叉树*；

$$
ASL=\frac1n\sum_{i=1}^{n}l_i\\
=\frac1n(1 * 1 + 2*2+...+h*2^{h-1})\\
=\frac{n+1}{n}log_2(n+1)-1\\
\therefore O(log_2n)
$$
其中，*h* 是树的高度，并且每个元素为 *n* 时树高 $h=[log_2(n+1)]$ 。所以，二分查找的时间复杂度为 $O(log_2n)$，平均情况下查找效率比顺序查找的效率高；



![[degree.master.c.05-树和二叉树#^cd86a6f7e9uj:#^v25hp7lycs3k]]



#### 特点

> 🤷‍♂️Again， 二分查找需要方便定位查找区域，所以不适用 *链式存储结构*；

- 基于顺序表存储结构；适合**一次排序，多次查找**。因此针对**有序且静态**数据。在动态数据集合中快速查找数据则考虑树查找；

- 数据量小，不需要二分。很直观地可以看到过程中有大量的判断语句分支，数据量小时不及顺序查找。

- 数据量太大时，即使对 `mid` 的计算时产生的整型溢出可以优化，但本身二分查找所要求的连续存储空间会耗费大量内存；不像顺序查找那样，可以将大量数据分段，作为流进行输入。



## 分块查找

> ❗块间有序，块内无序

分块查找又称 *索引顺序查找* ，它吸取了顺序查找和折半查找各自的优点，既有动态结构又适合于快速查找。块内的元素的无需的，块之间是有序的。

**分块有序**，即分成若干子表，要求每个子表中的数值都比后一块中数值小(但子表内部未必有序)。然后将各子表中的最大关键字构成一个索引表，表中还要包含每个子表的起始地址（即头指针）。

<img src="https://cdn.notcloud.net/static/md/cy948/202211032136100.png" alt="image-20221103213644055" style="zoom: 50%;" />

### 特点

分块查找算法的运行效率受两部分影响：查找块的操作和块内查找的操作。所以平均查找长度为：
$$
ASL=L_I+L_S
$$

> 🛑以下内容可以理解

将长度为 *n* 的查找标均匀地分为 *b* 块，每块有 *s* 个记录，再等概率的情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为：
$$
ASL=L_I+L_S=\frac{b+1}{2}+\frac{s+1}2\\
=\frac{s^2+2s+n}{2s}
$$

此时，若 $s=\sqrt{n}$，则平均查找长度取最小值 $\sqrt{n}+1$ ；若对索引表采用折半查找时，则平均查找长度为：
$$
ASL=L_I+L_S=[log_2(b+1)] + \frac{s+1}2
$$
🔎 查找块的操作可以采用顺序查找，也可以采用折半查找（更优）；块内查找的操作采用顺序查找的方式。

## 树型查找

### 二叉排序树

![[degree.master.c.05-树和二叉树#二叉排序树:#^4qnxcb6a1v3g]]



#### 查找

从根节点开始，沿着某个分支向下比较的过程：

- 若二叉排序树不为空，先比较二叉树和目标值，若相等，则成功；
- 若不等：
  - 小于则往左寻找；
  - 大于则往右寻找；

通常，取二叉链表作为二叉排序树的**存储结构**：

```c
typedef struct { // 结点的数据域结构
    KeyType   key; //关键字项
    InfoType  otherinfo;  // 与关键字相关的其他数据项
}ElemType;

typedef struct BSTNode { // 结点结构
    ElemType  data;
    struct BSTNode *lchild, *rchild;      // 左右孩子指针
}BSTNode, *BSTree;
```

搜索**算法**：

```c
BSTree SearchBST(BSTree T, KeyType key){
   if((T == NULL) || key == T->data.key){
		return T;
   }else if(key < T->data.key){
		return SearchBST(T->lchild, key);
       //在左子树中继续查找
   }else return SearchBST(T->rchild, key);    		 
    //在右子树中继续查找
}
```

#### 插入/构造

> 二叉排序树作为一种动态的链表，其特点是树的结构通常不是一次生成的，而是在查找中不断插入的。

- 若二叉排序树为空，则插入结点应为根结点；
- 否则，继续在其左、右子树上查找：
  - 树中已有，不再插入
  - 树中没有，继续查找；
  - 🔁查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子。

> ❗插入的元素一定在叶结点上！

```c
int InsertBST(BSTree * T, ElemType e) {
   // 当二叉排序树T中不存在关键字等于e.key 的
   // 数据元素时，插入该元素。
   if (T == NULL){   
       s = malloc(sizeof(BSTNode));
       s->data = e;
       s->lchild = s->rchild = NULL;
       return 1;
   }
   else if (e.key < T.data.key)
       return InsertBST(T -> lchild, e);
   else if (e.key > T.data.key)
       return InsertBST(T -> rchild, e);
} // Insert BST
```

**构造**：依照一个列表依次插入二叉排序树

```c
void CreateBST(BiTree * T, ElemType * keys, int size){
    T = NULL; //初始化 T 为空树
    int i = 0;
    while(i < size){
        InsertBST(T,keys[i++]);
    }
}
```



#### 删除

> ❗ 删除时能简单地把以该节点为根的子树直接删除，删除出后性质必须保持不变；

可分三种情况讨论*被删除的结点*：
1. 是叶子，直接删；
2. 只有左子树或者只有右子树，用子树填补；
3. 既有左子树，也有右子树。

此处直接讨论*既有左子树，也有右子树* 的情况：

1. 因为被删除的结点有左、右子树，所以需要找一个结点：

- 比被删结点的左子树都要大，只能在右子树寻找；
- 也不能太大，因为该结点将替换被删结点，所以该值需要比右子树的值都要小。也就是右子树的“中序遍历第一个结点”；

2. 细化方案：

- 首先，找到其右子树的中序第一个结点，我们知道其通常位于树的最左边。方案是使用 `while` 循环向左进行 `DFS` ，如 `T->left == NULL` ，即结点没有左子树，即为当前树结点的最小值，即：“中序遍历第一个结点”；
- 然后，调用方法对该结点进行删除；
- 最后，将该结点的值替换到待删除结点的值；

> 题目不难

LC [450. 删除二叉搜索树中的节点 - 力扣（Leetcode）](https://leetcode.cn/problems/delete-node-in-a-bst/description/) 参考：[450. 题解](https://leetcode.cn/problems/delete-node-in-a-bst/submissions/379499753/)

>  采用递归算法，每一层递归都向上一层返回删除完成后的根结点；

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode* deleteNode(struct TreeNode* root, int key){
    if (root == NULL) return NULL;
    // 如果根结点的值大于目标值
    // 则目标结点只可能位于左子树
    if (root->val > key)
        root->left = deleteNode(root->left, key);return root;
    if (root->val < key)
        root->right = deleteNode(root->right, key);return root;

    // 如果左右子树均存在
    if (root->left && root->right) {
        // 寻找中序遍历的第一个结点
        struct TreeNode * firstInOrder = root->right;
        while (firstInOrder->left) {
            firstInOrder = firstInOrder->left;
        }
        // 从树上删除该结点
        root->right = deleteNode(root->right, firstInOrder->val);
        // 然后把该结点替换掉待删除的目标结点
        firstInOrder->right = root->right;
        firstInOrder->left = root->left;
        // 删除目标结点
        // free(root)
        return firstInOrder;
    }

    // 如果右子树为空
    if (root->right == NULL) {
        struct TreeNode * left = root->left;
        //free(root);
        return left;
    }
    // 左子树为空
    struct TreeNode * right = root->right;
    //free(root);
    return right;
}
```



#### 查找效率分析

在前面二分查找形成的二叉树可以知道：二叉树的查找效率重要取决于树的层数。若二叉树排序树的：

- 高度之差绝对值不超过1，则这样的二叉排序树称为 *平衡二叉树* 它的平均查找长度为 $O(log_2n)$，下文会介绍。
- 若二叉排序树是一个只有左孩子/右孩子的 *单支树* （类似于有序链表），则其平均查找长度为 $O(n)$ 。

<img src="https://cdn.notcloud.net/static/md/cy948/202211051511260.png" alt="image-20221105151112219" style="zoom:80%;" />

<center>
    <h4>
        图7.8 相同关键字依照不同顺序输入的不同二叉排序树
    </h4>
</center>

**一般情况**

如上图 `a` 所示：
$$
ASL_{\text{a.成功}}=(1+2*2+3*4+4*3)/10=2.9
$$
**最坏情况**

输入的序列是有序的，则会形成一个倾斜的单支树，如图 `b` 所示；
$$
ASL_{\text{b.成功}}=(1+2+3+4+5+6+7+8+9+10)/10=5.5
$$
其查找成功的 `ASL` 为：



**总结**

在查找过程中，二叉排序树和二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同关键字其插入顺序的不同可能生成不同的二叉排序树，就如上图 `7.8` 那样。

> 🤔 若在二叉排序中删除并插入某结点，得到的二叉排序树和原来的一样吗？
>
> 不一定一样。分情况讨论：
>
> 1. 左右子树均为空。一样。
>
> 2. 左右子树任一为空。不一样。
>    - 若左子树为空，删除后补充的是其右子树，重新插入后位于其右子的左子树中；
>    - 右子树同理；
> 3. 均不为空。不一样
>    - 重新插入时新结点只能位于左子树中。



### 平衡二叉树

为避免二叉排序树的高度增长过快，出现上图中的 *单支树* 情况，规定在插入或删除操作时，要保证任意结点的左、右子树高度查的绝对值不超过 *1* ，将这样的二叉树称为 **平衡二叉树** (Balanced Binary Tree)，简称 *平衡树* 。定义结点左子树与右子树的高度差为该结点 *平衡因子* ，则平衡二叉树的平衡因子的值只可能是 *1, -1, 0* 。

> 下图结点中的值为平衡因子，计算公式为：
>
> 结点左子树高度 - 结点右子树高度

![image-20221105153131117](https://cdn.notcloud.net/static/md/cy948/202211051531152.png)

#### 插入

每插入一个结点，就要检查是否导致平衡二叉树失衡，若失衡，则进行调整，调整情况如下：

> ❗**图例**：为了有针对性地展示一颗正常工作的平衡二叉树，我们引入了虚拟子树 ，图中使用矩形表示。该虚拟子树自带*高度* H  ，可以通过该 *高度* 计算出其父亲的平衡因子；

1. **LL 平衡旋转（右单旋转）**。由于在结点 *A* 的左孩子B（*L* 该标号仅为说明旋转方法的名字来源，不代表具体结点）的左子树 *BL*（*LL*）上插入了新结点，*BL* 的高度变为 *H+1*，*T* 的平衡因子由 *1* 增至 *2*，导致以 *T* 为根的子树失去平衡，需要一次向右的旋转操作。

![image-20221105221830863](https://cdn.notcloud.net/static/md/cy948/202211052218903.png)

过程包括：

```c
BSTNode * B = A->left; //保存一下B
A->left = B->right; //B->right是BR
B->right = A;
```

2. **RR 平衡旋转（左单旋转）**。同理，结点 *A* 的右孩子B（*R* ）的右子树 *BR*（*RR*）上插入了新结点，*BR* 的高度变为 *H+1*，*A* 的平衡因子由 *-1* 减至 *-2*，导致以 *A* 为根的子树失去平衡，需要一次向左的旋转操作。

```c
BSTNode * B = A->right; //保存一下B
A->right = B->left; //B->left是BL
B->left = A;
```

![image-20221105222335032](https://cdn.notcloud.net/static/md/cy948/202211052223067.png)

3. **LR 平衡旋转（先左后右双旋转）**

<img src="https://cdn.notcloud.net/static/md/cy948/202211082127193.gif" alt="localtestwithplugins" style="zoom:50%;" />

结点 *A* 的左孩子B（*L* ）的右子树 *BR*（*R*）上插入的新结点 *C* 替换了 *BR*，新增了 *CL* 和 *CR*，高度分别为 *H* (H - 1 + 1) 、*H-1* (H - 1)，*A* 的平衡因子由 *1* 增至 *2*，导致以 *A* 为根的子树失去平衡，需要二次旋转操作。

<img src="https://cdn.notcloud.net/static/md/cy948/202211052248754.png" alt="image-20221105224844709" style="zoom: 80%;" />

**手动模拟：**

- 插入 *C* ，*A* 失衡

![image-20221108214955954](https://cdn.notcloud.net/static/md/cy948/202211082149994.png)

- **提C换B**。 为把 *C* “提”到 *B* 的位置，需要两步走：
  - 分别断开 *A->B* 、*B->C*、*C->CL*，然后连接 *B->CL*，
  - 然后将 *C* 提到 *B* 的位置；
  - 连接 *A->C* 、*C->B*；


<img src="https://cdn.notcloud.net/static/md/cy948/202211082221872.png" alt="image-20221108222140825" style="zoom:80%;" />

- **LL**。
  - 去掉 *A->C* 、*C->CR*，连接 *A->CR*；
  - 将 *C* 向上提；
  - 连接 *C->A* ；

<img src="https://cdn.notcloud.net/static/md/cy948/202211082223677.png" alt="image-20221108222302629" style="zoom:80%;" />

4. **RL 平衡旋转（先右后左双旋转）**

<img src="https://cdn.notcloud.net/static/md/cy948/202211082131770.gif" alt="localtestwithplugins" style="zoom:50%;" />

结点 *A* 的右孩子B（*R* ）的左子树 *BL*（*L*）上插入的新结点 *C* 替换了 *BL*，新增了 *CL* 和 *CR*，高度分别为 *H* (H - 1 + 1) 、*H-1* (H - 1)，*A* 的平衡因子由 *-1* 减至 *-2*，导致以 *A* 为根的子树失去平衡，需要二次旋转操作。

![image-20221105230100176](https://cdn.notcloud.net/static/md/cy948/202211052301226.png)

> ❗注意，*LR* 和 *RL* 旋转时，上述新结点到底是插入 *C* 的左子树还是右子树不影响旋转过程
>
> 旋转的**命名规律**：命名即将失衡结点为 *A* ，插入 A 的左结点的左子树就是 LL，进行 *LL* 旋转、插入 *A* 的右结点的左子树树就是 *RL*，执行 *RL* 旋转；
>
> *LR&RL* 的旋转规律：以 *C* 为新的顶点，B换到对面，A往下移动；

#### 插入过程

- `d` ：插入 *7* 后，结点 `15` 平衡因子为 *2*，执行 `LR` 旋转；
- `g` ：插入 *9* 后，结点 `15` 平衡因子为 *2* ，执行 `LL` 旋转；

![image-20221108210422700](https://cdn.notcloud.net/static/md/cy948/202211082104750.png)



#### 删除

其实就是反过程，理解插入即可



#### 查找

同二分查找。在查找过程中，与给定值进行比较关键字的个数不超过树的深度。含 *n* 个结点的平衡二叉树的最大深度为 $O(\log_2 n)$ ，因此二叉平衡树的平均查找长度为 $O(\log_2{n})$ 

> ❗该结论可用于求解给定结数的平衡二叉树的查找平均所需的**最多**比较次数
>
> *AVL* 树最小节点数递推公式：
> $$
> n_0 = 0, n_1 = 1, n_2 = 2 \\
> n_h = 1 + n_{h-1} + n_{h-2}
> $$



### * 红黑树

为了保持树的平衡性，插入和删除操作后，非常频繁地调整全树的整体拓扑结构，代价很大。为此在 *AVL* 树的平衡标准上进一步放宽条件，引入了红黑树的结构。红黑树具有以下**性质**：

1. 每个结点是 “红” 或 “黑” 的；
2. 根结点为 “黑”；
3. 叶结点（虚拟的外部结点、NULL结点）都是黑色的；
4. 不存在两个相邻的 “红” 结点（即红结点的父结点和孩子结点均为黑色的）；
5. 对每个结点，从该结点到任一结点的简单路径上，所含黑结点的数量相同；

与折半查找树和 *B* 树类似，为了便于对红黑树的实现和理解，引入了 *n+1* 个外部叶结点，以保证红黑树每个结点（内部结点）的左、右孩子均非空。

<img src="https://cdn.notcloud.net/static/md/cy948/202211131145048.png" alt="image-20221113114459989" style="zoom:80%;" />

**黑高**：从某结点出发（不含该结点）到达一个叶结点的任一简单路径上的黑结点总数称为该结点的 **黑高** （记为 *bh*）；

**结论1：从根结点到叶结点的最长路径不大于最短路径的 *2* 倍**

- 由性质5，从该结点出发到任一叶结点的简单路径最短时，该路径必然全由黑结点构成。*6 -> 20*
- 由性质3，当某条路径最长时，该路径必然是由黑结点和红结点相间构成的，此时红结点和黑结点数量相同。*6 -> 15 -> 18 -> 20*



**结论2：有 *n* 个内部结点的红黑树的高度 ** $h \le 2\log_2 (n+1)$

由结论 *1* 可知，从根结点到叶结点（不含叶结点）的任何一条简单路径上至少有一半是黑结点，因此，根的黑高至少为 *n/2* ，于是有 $n \ge 2^{h/2} - 1$ ，简单变换后即证。



红黑树的**“适度平衡”**：由 *AVL* 树的“高度平衡”降低到 “任一结点左右子树的高度，相差不超过 *2* 倍”，也降低了动态操作时调整的频率。 对于一颗动态查找树：

- 如果插入和删除操作比较少，查找操作比较多，则用 *AVL* 树；
- 反之，使用红黑树。如：C++中的 map 和 set，Java中的 TreeMap 和 TreeSet；



#### 插入

与 *AVL* 树的过程类似，不同在于插入后需要进行 “染色” 以满足红黑树的性质。



**结论3：红黑树的结点初始着为红色**

> 假如新加入新插入的结点初始为黑色，每次插入都会使得该结点所在路径比其他路径多出一个黑结点（黑结点包含叶结点，至少占总结点数的一半）破坏性质5，调整较为麻烦。如果插入结点为红色，则有概率使得黑结点数不变，调整较为简单。

设 *z(B)* 为新插入的结点。插入过程描述如下：

**情况1、2：*z* 的叔结点 *y* 是黑色**

1. 用二叉查找树的插入法插入，并将结点 *z* 着为红色。若结点 *z* 的父结点是黑色的，无须做任何调整，此时就是一颗标准的红黑树；

2. 如果结点 *z* 是根节点，将 *z* 着为黑色，结束；

3. 如果结点 *z* 不是根节点，并且 *z* 的父节点 *z.p(A)* 是红色的，插入前的树是合法的，根据性质 *2* 和 *4* ，爷结点 *z.p.p(C)* 必然存在并为黑色，性质 *4* 在 *z.p* 和 *z.p* 之间被破坏了；分为两种情况：

   1. *z* 的叔结点 *y* 是黑色的，且 *z* 是一个右孩子；如图中7.19中的《情况1》：新插入的结点 *z(B)* 位于红色结点 *z.p(A)* 的右子树；

   2. *z* 的叔结点 *y* 是黑色的，且 *z* 是一个左孩子；如图中7.19中的《情况2》：新插入的结点 *z(B)* 位于红色结点 *z.p(A)* 的左子树；

![image-20221113162843264](https://cdn.notcloud.net/static/md/cy948/202211131628313.png)

4. 情况`1`：
   - 先断开 *A->B, C->A, B->T2*，连接 *A->T2* *交换孩子*；
   - 再连接 *C->B, B->A* ，“左旋” 把 *B* “提”起来，转化为情况2；

5. 情况`2`：
   - 断开 *B->T3,* 连接 *C->T3* ，然后将 *C* 变红，*B* 变黑，相当于一次 “右单旋” 后染色；

> 同理可得上述情况的水平对称版本（即  *A* 为 *C*的右子树）



**情况3：*z* 的叔结点 *y* 是红色**

很简单，以 *z(B)* 为起点，将 *z.p(A), y(D)* 染为黑色， *z.p.p(C)* 染为红色。🔁将 *z.p.p* 再作为起点重复上述步骤直到 *z* 上移到根节点或满足情况 *1/2* 的条件。

![image-20221113165553980](https://cdn.notcloud.net/static/md/cy948/202211131655026.png)

❓是否存在不断上升的可能？

不存在，因为往上如果遇到根节点，直接结束。

![image-20221113172242818](https://cdn.notcloud.net/static/md/cy948/202211131722880.png)



#### 删除

>  红黑树的插入操作容易导致连续的两个红结点，破坏性质4，而删除操作容易造成子树黑高的变化，破坏性质5。

删除过程叶是先执行二叉查找树的删除方法。若待删除结点有两个孩子，则不能直接进行删除，与AVL树的删除类似：要找到该子树的最小结点（结点的中序后继（或前驱））填补 ，然后删除该结点。

> 过。。



### B 树

>  当使用二叉查找树（二叉排序树/AVL树/红黑树）进行查找的时候，一次只能得到一个键值的信息，而用多叉树，可以得到最多M-1（M：树的阶）个键值的信息。因此，对于同样的数据量，二叉查找树的深度大，而多叉树的深度小，因此多叉树适用于要求查找深度小的检索。
>
> ❓什么场合的查找会要求查找深度小？
>
> 在**大规模数据存储的索引查询**中，由于无法一次性加载所有索引数据到内存里，所以在索引查询时要进行内外存交换。而**内外存交换次数越少，效率表现也越高**。若某个多路查找树深度为3，每个结点存储1000个索引数据，则共可存储超10亿个索引。若操作系统每次可将一个节点的数据读入内存，则最多进行3次内外存交换就可以查找到所需索引数据。若使用二叉查找树，则深度至少为30。
>
> ```c
> 
> ```
>
> 

B树，又称 *多路平衡查找树* ，*B* 树中所有结点的孩子个数的最大值称为 *B* 树的 **阶**，通常用 *m* 表示。一颗 *m* 阶 *B* 树或为空树，或满足如下特性的 *m* 叉树：

1. ❗树中每个结点至多有 *m* 颗子树，最多含有 *m-1* 个关键字；
2. ❗若根节点不是终端结点，则最少有 *2* 颗子树；
3. ❗**除根节点外的所有非叶结点最少有 $\lceil m/2 \rceil$ 颗子树**，最多含有 $\lceil m /2 \rceil-1$ 个关键字；$\lceil m \rceil$ 表示对 *m* 向上取整为整数，如：$\lceil 5/2 \rceil=3$；
4. 所有非叶结点的结构如下：

| n    | $P_0$ | $K_0$ | $P_1$ | $K_1$ | $P_2$ | ...  | $K_n$ | $P_n$ |
| ---- | ----- | ----- | ----- | ----- | ----- | ---- | ----- | ----- |

其中：

- $K_i \ (i=1,2,...,n)$ 为结点的关键字，且满足 $K_1<K_2<...<K_n$ ；
- $P_i(i=0,1,...,n)$ 为指向子树根结点的指针，且指针 $P_{i-1}$  所指的子树中含有的所有结点关键字均小于 $K_i$，$P_{i}$ 的则大于 $K_i$；
- n（ $\lceil m/2 \rceil - 1 \le n \le m-1$ ）为结点中关键字的个数；

> 🤔如何记忆？
>
> B树最重要的性质是：除根节点外的所有非叶结点最少有 $\lceil m/2 \rceil$ 颗子树，关键字位于两颗子树中间，因此最少有 $\lceil m/2 \rceil - 1$ 个关键字。子树数量最大时等于B树的度，即至多有 *m* 颗子树，同理，含 *m-1* 个关键字；

5. 所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部查找结点或类似折半查找判定树的查找失败结点，实际上这些结点并不存在，指向这些结点的指针为空）



*B* 树是所有结点的平衡因子均等于 *0* 的多路平衡查找树。以下是一颗 *5*  阶*B* 树：

^duheimxdzg2e

![image-20221113213943593](https://cdn.notcloud.net/static/md/cy948/202211132139652.png)

^ypam504xs6al

- 结点的孩子数量等于该结点中关键字个数+1；
- 如果根节点没有关键字，就没有子树，此时 *B* 树为空；如有，则其子树必 $\ge2$ ，因为子树个数等于关键字个数 +1；
- 除根结点外的所有非终端结点至少有 $\lceil m/2 \rceil = \lceil 5 / 2\rceil = 3$ 颗子树（即至少有 $\lceil m/2 \rceil - 1 = \lceil 5/2\rceil - 1 = 2$ 个关键字），至多有 $m=5$ 棵子树， $m-1 = 4 $ 个关键字；
- 结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指向子树的所有关键字都小于该关键字，反之右边指针则大于该关键字。或看成 **下层结点的关键字总是落在由上层所划分的区域内** ；
- 所有叶结点均在第 *4* 层，代表查找失败的位置；



#### B树的高度（磁盘存取次数）

*B* 树中的大部分操作所需的磁盘存取次数于 *B* 树的高度成正比。❗此处明确高度不包括 *不带任何信息的最后一层* ；

若 $n \ge 1$ ，则对任意一颗包含 $n$ 个关键字、高度为 *h*、阶数为 *m* 的 *B* 树：

1. 因为 *B* 树中每个结点最多有 *m* 颗子树，*m-1* 个关键字，所以在一颗高度为 *h* 的 *m* 阶 *B* 树中关键字的个数应满足 $n \le (m-1)(1+m+m^2+...+m^{h-1})$ ，因此有：

$$
h \ge \log_m (n+1)
$$

2. 若让每个结点中的关键字个数达到最少，则容纳同样关键字最多的 *B* 树的高度达到最大。

由B树的定义：

- 第一层至少有 *1* 个结点；第二层至少有 *2* 个结点；
- 除根结点外的每个非终端结点至少有 $\lceil m/2 \rceil $ 棵子树，则第三层至少有 $2\lceil m/2 \rceil$ 个结点 ... 第 *h+1* 层至少有 $2(\lceil m/2\rceil)^{h-1} $ 个结点，并且 *h+1* 层的结点是不含信息的叶结点；
- ❗对于关键字为 *n* 的 *B* 树，叶结点即查找不成功的结点为 *n+1* 由此有 $n+1\ge 2(\lceil m/2\rceil )^{h-1}$ ，即 $h\le \log_{\lceil m/2\rceil } ((n+1)/2)+1$ (最大高度公式)。例如一颗 *3* 阶 *B* 树共有 *8* 个关键字，则其高度范围为 $2 \le h \le 3.17$；

> ❗最小高度公式：
> $$
> h \ge \log_{m} (n+1)
> $$



#### B树的查找

与二叉查找树类似，只是每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支决定，而是根据该结点的子树所作的多路分支决定；

*B* 树的查找包含两个基本操作：

- 在 *B* 树上找结点；
- 在结点上找关键字；

由于 *B* 树常常存储在**外存**（磁盘）上，因此前一个查找是在磁盘上进行的，而后一个查找是在内存中进行的，即在**找到目标结点后，先将结点信息读入内存，然后在结点内采用 *顺序查找法* 或 *折半查找法*** 。

> 在 *B* 树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找，如图中查找关键字 *42*：
>
> ![[degree.master.c.08-查找#^duheimxdzg2e:#^ypam504xs6al]]
>
> - 从根结点开始，42 > 22，若存在必在右子树中；
> - 右孩子有两个关键字， 26 < 42 < 45，则若存在，必在中间；
> - 查找到叶结点时，若无对应关键字则失败；



#### B树的插入

1. 定位。利用前述的 *B* 树查找算法，找出插入该关键字的最低层的某个非叶结点。❗插入位置一定是最下层的非叶结点。
2. 插入。 每个非失败结点的关键字个数都在区间 $[\lceil m/2 \rceil - 1,m-1]$ 内。插入后的结点关键字个数小于 *m*，可以直接插入；插入后检查被插入结点的关键字个数：
   - $< m$ 。可以直接插入，完成✅；
   - $> m-1$ ，必须对结点进行分裂；

3. 分裂。取一个新结点，在插入 *key* 后的原结点，从中间位置 $\lceil  m/2 \rceil$ 将其中的关键字分为两部分：

   - 左部分包含的关键字放在原结点中；
   - 右部分包含的关键字放到新结点中；
   - 中间位置 $\lceil m/2 \rceil $ 的结点插入原结点的父结点；

   > 🔁若此时父结点的关键字也超过了上限，则继续进行这种分裂操作，直至这个过程传到根节点为止，进而导致 *B* 树高度增1；

过程如图：

![image-20221114104318149](https://cdn.notcloud.net/static/md/cy948/202211141043190.png)



#### B 树的删除

与插入相反，会涉及到 B 树的合并操作。若删除后的关键字个数 $< \lceil m/2 \rceil - 1$，则进行合并。针对删除的对象，以下有两种情况：

1. 被删关键字 *k* 不位于最底层（终端结点）中：利用 *k* 的前驱（或后继 *k'*） 替代 *k* ，然后再删除 *k'* 。如图：

![image-20221114105516161](https://cdn.notcloud.net/static/md/cy948/202211141055195.png)

2. 当被关键字位于最底层（终端结点）时，有三种情况：

- 直接删除关键字，所在结点的关键字个数 $> \lceil m/2 \rceil - 1$ ，删完仍满足定义，直接删即可✅；
- 兄弟够借，就借。若被删结点删除前个关键字个数 $= \lceil m/2 \rceil - 1$，相邻的兄弟中关键字个数 $\ge \lceil m/2 \rceil - 1$ ，则需要调整该节点、右（或左）兄弟极其双亲结点（父子换位法），以达到新的平衡。
	> 如图 (a) 中删除 *4* 阶 B树的关键字 *65*，右兄弟关键字个数 $\ge \lceil m/2 \rceil  = 2$ ，将 *71* 取代原 *65* 的位置，将 *74* 调整到*71* 的位置：
	>
	>![image-20221114110408533](https://cdn.notcloud.net/static/md/cy948/202211141104565.png)

- 兄弟不够借，得合并。若被删除关键字所在结点删除前的关键字个数 $= \lceil m/2 \rceil - 1$ ，且此时与该结点相邻的左、右兄弟结点的关键字个数均 $= \lceil m/2 \rceil - 1$，则将关键字删除后与左（或右）兄弟结点及双亲结点中关键字进行合并。 

	> 如图 (b) 中，删除 *4* 阶B树关键字 *5*，它极其右兄弟结点的关键字个数 $= \lceil m/2 \rceil - 1 = 1$ ，故在 *5* 删除后将 *60* 合并到 *65* 结点中。
	>
	> ![image-20221114110823177](https://cdn.notcloud.net/static/md/cy948/202211141108211.png)

🔁在合并过程中，双亲结点的关键字个数会减1，若其双亲结点是根节点且关键字个数减少至 0 （根节点减少至 *0* 时，有 *2* 棵子树），则直接将根节点删除，合并后的新结点称为根；若双亲结点不是根节点，且关键字个数减少到 $\lceil m/2 \rceil - 2$ ，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至B树符合条件为止。



### B+树

B+树是应数据库所需而出现的一种B树的变形。

一颗 *m* 阶的B+树需满足以下**条件**：

1. 每个分支结点最多有 *m* 棵子树（孩子结点）；
2. 非叶根节点至少有两颗子树，其他每个分支结点至少有 $\lceil m/2 \rceil$ 棵子树；
3. 结点的子树个数与关键字个数相等；
4. 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。
5. 所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。



*m* 阶的 B+树与 *m* 阶的 B 树的 **主要差异** 如下：

1. 在B+树中，具有 *n* 个关键字的结点只含有 *n* 棵子树，即每个关键字对应一颗子树；而在B树中，具有 *n* 个关键字的结点含 *n+1* 棵子树；
2. 在B+树中，每个结点（非根内部结点）的关键字个数 *n* 的范围是 $\lceil m/2 \rceil \le n \le m$ （根节点 $2 \le n \le m$  ）；在B树中，每个结点（非根内部结点）的关键字个数 *n* 的范围是 $\lceil m/2 \rceil -1 \le n \le m-1$ （根节点 $1 \le n \le m -1$ ） 
3. 在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不包含该关键字对应记录的存储地址。
4. 在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点（最外层内部结点）包含的关键字和其他结点包含的关键字是不重复的。

#### B+树的查找

如下图所示，一颗 *4* 阶的 B+树，分支结点中的某个关键字是其子树中最大关键字的副本。通常在B+树中有两个头指针：一个指向根节点，另一个指向关键字最小的叶结点。因此，可以对B+树进行两种查找运算：一种是从关键字最小的开始的顺序查找，另一种是从跟结点开始的多路查找：

- **多路查找**。在进行缩小范围的查找时，不管成功与否，都必须查到叶子结点才能结束；
- **顺序查找**。 若在结点内查找时，给定值 $K_i$， 则应继续在 $A_i$ 所指子树中进行查找；

![--](https://cdn.notcloud.net/static/md/cy948/202211141139856.png)

B+树的插入、删除操作和B树类似，必要时进行“删除”和“合并”；

## 散列表

前面介绍的线性表和树表中，记录在表中的位置与记录的关键字之间不存在确定的关系，因此，这些表查找时需进行一系列的关键字比较。这类查找方法建立在“比较”的基础上，查找的效率取决于比较的次数。

**散列函数**：一个把查找表中关键字**映射**成该关键字对应的地址的函数，记为 `Hash(key) = Addr` （这里的地址可以是数组的下标、索引或内存地址等）。

> 散列函数有可能将多个关键字映射到同一地址上，这种情况称为 *冲突* ，这些发生碰撞的不同关键字称为 *同义词* 。一方面要在设计散列函数时尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以要设计好冲突处理方案。

**散列表**：根据关键字而直接访问的数据结构。<u>也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系</u>。

理想情况下，对散列表进行查找的时间复杂度为 $O(1)$，即与表中的元素的个数无关。下面介绍常用的散列函数和处理冲突的办法。



### 散列函数构造办法

**要求**：

1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围；
2. 散列函数计算存储出的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生；
3. 散列函数应该尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址；
4. 散列函数应尽量简单，能够在较短时间内计算出任一关键字对应的散列地址；



**1. 直接定址法**

直接取关键字的某个**线性**函数值为散列地址，散列函数为：
$$
H(key) = key \\
or \ H(key) = a * key + b
$$
*a* 和 *b* 是常数。这种方法计算最简单，且不会产生冲突。它最适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。



**2. 除留余数法**

这是一种最简单、最常用的方法，假定散列表表长为 *m* ，取一个不大于 *m* 但最接近或等于 *m* 的**质数** *p*，利用以下公式把关键字转换成散列地址。散列函数为：
$$
H(key) = key \% p
$$
除留余数法的关键是选好 *p*，使得每个关键字通过该函数转换后等概率地映射散列空间上的任一地址，从而尽可能地减少冲突的可能性。



**3. 数字分析法**

设关键字是 *r* 进制树（如十进制数），而 *r* 个数码在各位上出现的概率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的的若干位作为散列地址。这种方法适合于已知的关键字集合，如更换了关键字，则需要重新构造新的散列函数。

**4. 平方取中法**

顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。

**小结**

在不同的情况下，不同的散列函数具有不同的性能，因此此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况，但目标是尽量降低产生冲突的可能性。





### 处理冲突的办法

任何设计出来的散列函数都不可能避免冲突，必须考虑为冲突的元素考虑下一个可存放的位置。

**1. 开放定址法**

所谓开放地址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：

$$
H_i = (H(key)+d_i) \% m 
$$

- $H(key)$ 为散列函数；
- $i=0,1,2,...,k(k \le m-1)$ ；
- $m$ 表示散列表表长；
- $d_i$ 为增量序列；

取某一增量序列后，对应的处理方法就是确定的。通常有 *4* 种方法：

- **线性探测法** 。 当 $d_i = 0,1,2,...,m-1$ 时，称为 *线性探测法* 。这种方法的特点是：冲突发生时，顺序查看表种的下一单元（探测到表尾地址 *m-1* 时，下一个探测地址是表首地址 *0* ），直至找出一个空闲单元（表没满肯定能找出）或遍历全表。

线性探测法可能使第 *i* 个散列地址的同一层次存入第 *i+1* 个散列地址，这样本该存入 *i+1* 的元素就会被后移，从而造成大量的元素在相邻地址上“聚集”或堆积起来，大大降低了查询效率。

- **平方探测法**。当 $d_i=0^0,1^2,-1^2,2^2,-2^2,..,k^2,-k^2$ 时，称为*平方探测法* ，其中 $k\le m/2$ ，散列表的长度 *m* 必须是一个可以表示 *4k+3* 的素数，又称 *二次探测法* 。

平方探测法是一种处理冲突的好办法，可以避免“堆积”问题，它的缺点是不能探测到散列表的所有单源，但至少能探测到一半单元。

- **双散列法**。当 $d_i=Hash_2(key)$ 时，称为 *双散列法* 。需要使用两个散列函数，当通过第一个散列函数 *H(key)* 得到的地址发生冲突时，则利用第一个散列函数 $Hash_2(key)$ 计算该关键字的地址增量。它的具体散列函数形式如下：

$$
H-i=(H(key)+i*Hash_2(key))\% m
$$

初始探测位置 $H_0=H(key) \% m$。*i* 是冲突的次数，初始为 *0* 。在双散列法中，最多经过 *m-1* 次探测就会遍历表种的所有位置，回到 $H_0$ 位置。

- **伪随机序列法**。当 $d_i=$ 伪随机数序列 时，称为 *伪随机序列法* 。

❗在开放定址的情形下，不能随便物理删除表中的已有元素，因为一旦这样做，有可能截断其他具有相同散列地址的元素的查找地址。因此可以对元素进行 *逻辑删除* ，也就进行“标记”。副作用是执行多次删除后，表面看上去很满，实际上并没有满，因此还需要定期维护散列表，把删除标记的元素物理删除。

**2. 拉链法**

就是把 *冲突* 的关键字存入一个链表中。把指向第一个元素的指针存在散列表的单元中。 拉链法适用于经常插入和删除的情况。

| ![image-20221115210709467](https://cdn.notcloud.net/static/md/cy948/202211152107508.png) | <img src="https://cdn.notcloud.net/static/md/cy948/202211152128559.png" alt="image-20221115212838467" style="zoom: 33%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |





### 散列查找及性能分析

散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字 *key* ，根据散列表函数可以计算出其散列地址，执行步骤如下：

初始化：`Addr = Hash(key)`；

1. 检测查找表中地址为 *Addr* 的位置上是否有记录，若无记录，则返回 *查找失败* ；若有记录，则比较它与 *key* 的值，若相等，则返回查找成功的标志，否则执行步骤2；

2. 用给定的处理冲突方法计算“下一个散列地址”，并把 *Addr* 置为此地址，转回步骤1；

例如，关键字序列 *{19, 14, 23, 01, 68, 20, 84, 27, 55, 11, 10, 79}* 按散列函数 $H(key)=key \% 13$ 和线性探测处理冲突所构造的散列表 *L* 如图：

![image-20221115212037311](https://cdn.notcloud.net/static/md/cy948/202211152120345.png)

给定值 *84* 的**查找过程**为：先求散列地址 $H(84) = 6$ ，因 *L[6]* 不为空且 $L[6] \ne 84$ ，则找第一次冲突处理后的地址 $H_1=(6+1) \% 16 =7$ ，而 *L[7]* 不空且 $L[7] \ne 84$ ，则找第二次冲突处理后的地址 $H_2=(6+2) \% 16 = 8$ ，*L[8]* 不空且 = *84*，查找成功，返回记录在表中的序号 *8*；

| 关键字   | 14   | 01   | 68   | 27   | 55   | 19   | 20   | 84   | 79   | 23   | 11   | 10   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 比较次数 | 1    | 2    | 1    | 4    | 3    | 1    | 1    | 3    | 9    | 1    | 1    | 3    |

平均查找长度 *ASL* 为
$$
ASL = (1*6+2+3*3+4+9)/12 \\
= 2.5
$$
对于每组关键字，设定相同的散列函数，则不同的冲突处理方法得到的散列表不同，它们的平均查找长度也不同，本例与上面“拉链法”中的例子的平均查找长度不同。

从查找过程中可见：

1. 虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需要以平均查找长度作为衡量散列表的查找效率的度量。
2. 散列函数的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。

**装填因子**。散列表的装填因子一般记为 $\alpha$ ，定义为一个表的 *装满程度* ，即
$$
\alpha = \frac{\text{表中记录数}n}{\text{散列表长度}m}
$$
散列表的平均查找长度依赖于散列表的装填因子 $\alpha$ ，而不直接依赖于 *n* 或 *m* 。直观地看，$\alpha$ 越大，表示装填的记录越“
满”，发生冲突的可能性越大，反之发生冲突的可能性越小。
