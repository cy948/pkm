---
id: 8l708l9a1j25jpdpb96rkgr
title: 09 排序
desc: ''
updated: 1668850676934
created: 1668849296190
---


> 掌握思想，过程，特征且能熟练编写关键代码

## 基本概念

排序就是重新排列表中的元素，使表中的元素有序的过程。

算法的**稳定性**。两个关键字相同的元素在排序后的次序与排序前的**相对位置**相同则 *稳定* ，否则 *不稳定*。 ❗稳定性并不能衡量算法的优劣，主要是对性质的描述。若关键字唯一，则不需考虑。

> 对于不稳定的算法，只需要列出一组关键字的事例说明其 *不稳定性* 即可

在排序的过程中，根据 **数据元素是否完全在内存中** 将排序算法分为：

- **内部排序**： 排序期间元素全部存放在内存中；

> 内部排序算法执行过程中都要进行两种操作：*比较* 和 *移动* 。通过比较两个关键字的大小，确定对应元素的先后关系，然后通过移动元素以达到有序。 这不是必然，如 *基数排序* 就不基于比较；

- **外部排序**： 排序期间元素无法全部同时存放在内存中，必须在排序的过程中不断地在内、外存之间移动；

❗每个排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。


## 插入排序

将每一个关键字按照大小插入之前已经排序好的子序列，直至插入完成。插入排序的思想可以引申出三个重要的排序方法：直接插入排序、折半插入排序和希尔排序。

### 直接插入排序

直接根据上面的思想得出一种直接排序的算法。

> 假设在排序过程中某时刻状态如下：
>
> - $L[index1,index2]$ 表示一个从下标 $index1$ 到 $index2$ 的子表；
> - $L(i)$ 表示下标为 *i* 的元素；

|有序数列 $L[1...i-1]$ |$L(i)$|无序数列 $L[i+1...n$ |
|--|--|--|

要将元素 $L(i)$ 插入有序的子序列中，需要执行以下操作：

1. 查找出 $L(i)$ 在 $L[1...i-1]$ 中的插入位置。
2. 将 $L[k...i-1]$ 中的所有元素依次后移一个位置。
3. 将 $L(i)$ 复制到 $L(k)$。

为了实现对 $L[1...n]$ 的排序，可以将 $L(2) \sim L(n)$ 依次插入前面已排好序的子序列，初始时可以将 $L[1]$ 视为一个已经排好序的子序列。 上述操作执行 *n-1* 次就能得到一个有序的表。 插入排序在实现上通常采用就地排序（空间复杂度为 $O(1)$），因而在向后比较的过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。

> 顺序表 `L[0]` 作为“哨兵”，不存放数据

```c
// 对顺序表 L 作直接插入排序
void InsertionSort(SqList * L) {
    int i,j;
    // L[1] 视为有序数列，此处从2开始排序
	for ( i=2; i<=L.length; ++i ){
        // 需要寻找插入位置，先复制到哨兵
		if (L.r[i].key < L.r[i-1].key) {
            L.r[0] = L.r[i]; // 复制到哨兵
            L.r[i] = L.r[i-1]; //必然要移动一个位置，先移动
			// 判断是否需要继续往前插入，
            // 如需则继续寻找插入位置，从 i-2 开始
            for(j=i-2; L.r[0].key < L.r[j].key; --j)
                L.r[j+1] = L.r[j];  // 记录后移
            L.r[j+1] = L.r[0]; // 插入到正确位置
       }
   }//for
} // InsertSort
```



**手动模拟过程**

![image-20221119191534686](https://cdn.notcloud.net/static/md/cy948/202211191915722.png)

**性能分析**

*空间效率*：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$

*时间效率*：在排序过程中，向有序子表逐个地插入元素的操作进行了 *n-1* 趟，每趟操作都分为 *比较关键字* 和 *移动元素*，而比较次数和移动次数取决于待排序表的初始状态：

- **最好**：表中已有序，都不用移动，复杂度为 $O(1)$；
- **最坏**：表中元素刚好与排序结果相反，为 $\sum^n_{i=1} i$ ，总的移动次数也达到最大，为 $\sum^n_{i=2}(i+1)$ ；
- **平均**情况下取上述最好、最坏情况的均值：$n^2/4$ ，即 $O(n^2)$ ；

> ❗大部分排序算法仅适用于顺序存储的线性表



### 折半插入排序

对上述直接插入排序的算法进行优化，将 *比较* 和 *移动* 的操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。

```c
// 对顺序表 L 作折半插入排序
void BiInsertionSort(SqList * L){   
    for (i=2; i <= L.length; ++i){
		L.r[0] = L.r[i];//同上，暂存L[i]到哨兵
        // 划定折半查找的界限是L[1-i-1]
        int low = 1, high = i-1, mid;
        while(low <= high){// 折半查找
			mid = low + (high - low) / 2;
            if(L.r[0].key < L.r[mid].key){
        		high = mid - 1;// 插入点在低半区
            }else{
                low = mid + 1; // 插入点在高半区
            }
		}//while
        // 找到插入位置(high)后，对元素进行后移
		for(j=i-1; j>=high+1; --j){
            L.r[j+1] = L.r[j];      // 记录后移            
        }//for
        L.r[high+1] = L.r[0]; // 插入
} // BInsertSort
```

> 🤔上述算法中为什么要在 L[high] 元素开始往后移动呢？如果想以 L[low] 元素开始往后移动，那要改变代码中的哪个部分呢？
>
> 手动模拟后可知，当完成比较后，high 指针的即是需插入的上一个位置，low 为插入的位置；
>
> ![image-20221119194618962](https://cdn.notcloud.net/static/md/cy948/202211191946989.png)
>
> ```c
> if(L.r[0].key < L.r[mid].key) // 比较语句
> ```
>
> | 次数 | low  | mid  | high | 比较结果  |
> | ---- | ---- | ---- | ---- | --------- |
> | 初始 | 1    |      | 5    |           |
> | 1    | 1    | 3    | 5    | ❌         |
> | 2    | 4    | 4    | 5    | ❌         |
> | 3    | 5    | 5    | 5    | ✔️         |
> | 4    | 5    |      | 4    | 🔚循环结束 |



**性能分析**

只改变了直接插入排序中的比较部分，约为 $O(n \log_2 n)$ ，比较次数与初始状态无关，仅取决于表中的元素个数 *n* ；而移动次数并未改变，它依赖于待排序表的初始状态。因此折半插入排序的时间复杂度仍为 $O(n^2)$ ，在**数据量不大**的时候能表现出很好的性能，是一种 **稳定** 的排序方法，只适用于**顺序存储**结构。



### 希尔排序

> 从前面的分析可知，直接插入排序的时间复杂度为 $O(n^2)$ ，但若待排序列为“正序”时，其时间复杂度可提高至 $O(n)$ ，可见其适合于基本有序的排序表和数据量不大的排序表。希尔排序基于这两点改进而来，对待排记录序列先作“宏观”调整(跳跃式地插入)，再作“微观”调整，又称 *最小增量排序*。

#### 概念

**出发点** 

- 直接插入排序在**基本有序**时，效率较高
- 在待排序的记录**个数较少**时，效率较高

**基本思想**

先将整个待排记录序列分割成若干子序列,分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。

**技巧**

子序列的构成不是简单地“逐段分割”，将相隔某个增量 $d_k$的记录组成一个子序列，让增量 $d_k$ 逐趟缩短（例如依次取5,3,1）直到 $d_k＝1$ 为止。

**优点**

小元素跳跃式前移，最后一趟增量为1时，序列已基本有序，平均性能优于直接插入排序。



#### 手动模拟

取一个小于 *n* 的步长 $d_1$ ，然后按照步长把关键字分成 $d_1$ 组，所有距离为 $d_1$ 倍数的放在同一租，在各组内进行直接插入排序，然后取第二个步长 $d_2, d_2 < d_1$ 。🔁 直至 $d_t = 1$ 。

以下图为例：

> ❓所有距离为 $d_1$ 倍数的子序列放在一组：
>
> 下图第二个中括号的 *13,55,38,76* 分别是步长为 *3* 的一组

- $d_1 = 5$ ，将该序列分成 *5* 个子序列（第一个大括号中的5行），分别对其内部进行直接插入排序；
- $d_2 = 3$， 将该序列分成 *3* 个子序列（第二个大括号中的3行），分别对子序列内部进行直接插入排序；

![image-20221119202806536](https://cdn.notcloud.net/static/md/cy948/202211192028573.png)



#### 实现

因为不同的 $d_k$ 值会对性能产生不同的影响，因此把固定的 $d_k$ 值装在数组 `dt[t]` 中，使用 `ShellSort` 主程序进行调用

```c
void ShellSort(SqList &L，int dt[ ]，int t)
{  //按增量序列dt[0…t-1]对顺序表L作Shell排序
     for(k=0; k<t; ++k) ShellInsert(L, dt[k]);
}

//增量为 dk 的一趟插入排序
void ShellInsert(SqList * L, int dk){
    // A[0]只是暂存单元，不是哨兵
    for(i = dk+1; i <= L.length; ++i)
    {// 每次循环跳过 dk 个元素，初始化时假设 L.r[1] 已经有序
        // 如果序列中下一个元素小于上一个元素
        if(L.r[i].key < L.r[i-dk].key){     
            // 将该元素记录到暂存中
            L.r[0] = L.r[i];
            // 不断往前隔 dk 找该元素的插入位置
            // 可以想象 i 元素迫使前面比他大的元素不断后移
            for(j=i-dk;
                 j>0 &&(L.r[0].key<L.r[j].key);
                 j=j-dk
            ){//将 i 前面的元素后移
				L.r[j+dk]=L.r[j];
            }// 将其他元素后移完毕，插入
            L.r[j+dk]=L.r[0];
        }//if
	}//for
}
```



#### 性能分析

**空间效率**：常数级辅助空间，为 $O(1)$ ；

**时间效率**：约为 $O(n^{1.25})$  ，最坏情况下仍为 $O(n^2)$ ；

**稳定性**：如上图，$\bar{49}$ 和 $49$ 在排序后的相对次序发生变化，不稳定；

**适用性**：仅适用于线性表为顺序存储的情况；

> 参数$d_k$的合理值：
>
> <details>
>     <summary>可据此考虑选项的优先级</summary>
>     <img src="https://cdn.notcloud.net/static/md/cy948/202211192114343.png" alt="image-20221119211406308" style="zoom: 67%;" />
> </details>
>
> ❗如上图，在进行排序时，元素 $L(i)$ 只会到 $L[i + k*d_k], k \in C$  位置，如需根据变动结果对步长进行判断时，需算出所有元素的位置移动，然后取最小；



## 交换排序

两两比较，如果发生逆序则交换，直到所有记录都排好序为止。

> 冒泡排序 $O(n^2)$
>
> 快速排序 $O(n \log_2 n)$



### 冒泡排序

> 从前往后/从后往前冒泡和升序两个概念不能弄混。
>
> 从前往后冒泡是指按照 升/降 序把 大/小 的元素从前面移动到后面。

#### 基本思想及算法

从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即$A[i-1]>A[i]$），则交换它们，直到序列比较完。称为第一趟冒泡，结果是最小元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最小的元素如气泡一样浮出水面（或最大的像石头沉底）。🔁下一趟开始时前一趟所确定的将不参加排列。如此重复最多 *n-1* 趟冒泡就能把所有元素排好序。

第一趟冒泡时：

- *27<49* ，不交换；*13<27*，不交换；
- *76>13* 交换；*97>13* 交换；*38>13*交换；*49>13*交换；

![image-20221120132414299](https://cdn.notcloud.net/static/md/cy948/202211201324337.png)

经过第一趟冒泡后，最小的元素已经交换到第一个位置，也是它的**最终位置**。以此类推，对剩余子序列采用同样的方法进行排序。

算法如下：

> 以下为从前往后，依次**把最大的元素放到最后**的冒泡算法。
>
> ❗如果一趟下来没有发生交换，证明数组已经有序，可终止循环。

```c
void bubble_sort(SqList * L){ 
    int i, j, 
    m = L.length-1, //初始化进行比较的子序列长度
    hasSwap=1; //是否发生交换的标志
    ElemType x;
    // m是子序列的长度,hasSwap==1为发生交换
    while((m>0)&&(hasSwap==1)){
        hasSwap = 0; //重置
        // 遍历子序列的每个元素
        for(j=1; j<=m; j++){
            // 如果前一个大于后一个，则进行交换
			if(L.r[j].key>L.r[j+1].key){
                flag=1;
                x=L.r[j]; L.r[j]=L.r[j+1]; L.r[j+1]=x; //交换
            }//endif
        }//endfor
        m--;
    }//endwhile
}
```



#### 性能分析

**空间效率**：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$ ；

**时间效率**：当初始序列有序时，显然第一趟冒泡后 `hasSwap == 0` ，直接退出循环，比较次数为 *n-1* ，移动次数为 *0*；当初始为逆序时，需要进行 *n-1* 趟排序，第 *i* 趟排序要进行 *n-i* 次关键字的比较，而每次比较后都必须移动元素 *3* 次来交换元素。

```c
x=L.r[j]; L.r[j]=L.r[j+1]; L.r[j+1]=x;
```

这种情况下：
$$
\text{比较次数}= \sum_{i=1}^{n-1}(n-i)= \frac{n(n-1)}{2} \\
\text{移动次数}= \sum_{i=1}^{n-1}3(n-i)=\frac{3n(n-1)}{2}
$$
结论，**最坏**情况下为 $O(n^2)$ ，其**平均**也为 $O(n^2)$ 

**稳定性**：**稳定**，看上述 *基本思想* 中的例子，若 *i>j* 且 *A[i] =  A[j]* 时不会发生交换，$\bar{49}$ 在运行后仍在 $49$ 的后面。

> ❗冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的所有元素的关键字一定小于或大于无序子序列中的所有元素的关键字，每趟排序后 **都会将一个元素放在其最终位置上**。



### 快速排序



#### 基本思想及算法

基于分治法：在待排序表 $L[1...n]$ 中任取一个元素 `pivot` 作为 *基准* （通常取首元素），以相对于 *基准* 的大小进行一趟排序将待排序表分为两个独立的两部分 $L[1...k-1]$ （ $< pivot$ ）和  $L[k+1...n]$ （$\ge pivot$ ），则 $pivot$ 放在了最终位置 $L(k)$ 上，这一过程称为 *一趟快速排序* （或 *一次划分*）。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素为空为止，即所有元素都放在了其最终位置上。

下面介绍一趟排序的过程：

>  是一个左右交替搜索和交换的过程。设左右搜索的指针为 *i,j* ，初始分别指向 *27,49* ，取第一个值 *49* 为 `pivot` 

指针 *j* 从右往左移动，找到第一个小于 `pivot` 的元素 *27*，将 *27* “剪切”然后“粘贴”到 *i* 所指向的位置；然后指针 *i* 从左往右移动，找第一个大于 `pivot` 的元素 *65* ，将其“剪切”然后“粘贴”到 *j* 指向的位置。

![image-20221120141431357](https://cdn.notcloud.net/static/md/cy948/202211201414397.png)

🔁如此循环往复直至两个指针相遇 *i = j*；然后进入下一趟排序，若待排序列中只有一个元素，显然已有序。

![image-20221120142251759](https://cdn.notcloud.net/static/md/cy948/202211201422803.png)

**算法如下：**

```c
void QSort ( SqList * L, int low, int high){  
     if(low < high){
         int pivotloc = Partition(L, low, high);
         Qsort(L, low, pivotloc-1); 
         Qsort(L, pivotloc+1, high);
     }
}

int Partition(SqList * L, int low, int high){
    int pivotkey = L.r[low].key;//将表中的第一个元素设为枢纽
	L.r[0] = L.r[low];//使用L[0]暂存顺序表的结构
	//进行一趟交换
    while(low < high){
        //从右往左开始扫描，如遇到比枢纽小的元素就退出循环
		while(low<high && L.r[high].key>=pivotkey)  --high;
        L.r[low] = L.r[high];//将比枢纽小的覆盖到左端
        //从左往右扫描，如遇到比枢纽大的就结束循环
        while(low<high && L.r[low].key<=pivotkey)  ++low;
        //交换
        L.r[high] = L.r[low];
    }
    //将暂存的元素放到最终位置，L.r[high]=L.r[0]也行
    L.r[low]=L.r[0]; 
    return low;
}
```



#### 性能分析

**空间效率**

由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大深度一致。**最好情况**：$O(\log_2 n)$；最坏时，*递归树成为单支树*，要进行 *n-1* 次递归调用，所以栈深度为**最坏情况**时为$O(n)$；**平均情况**下为：$O(\log_2 n)$；

**时间效率**

> 若待排记录的初始状态为按关键字有序时，快速排序将蜕化为起泡排序，其时间复杂度为O(n2)。

为避免出现这种情况，需在进行一次划分之前，进行“**预处理**”，即：先对 $R(s).key, R(t).key$ 和 $R[\lfloor (s+t)/2\rfloor].key$ (这三个数就是首、尾和中间)，进行相互比较，然后**取**关键字为**“三者之中”**的记录为**枢轴记录**。

在这种情况下，快速的排序的运行速度大大提高，为：$O(n\log_2 n)$ ，与最佳运行时间很接近。**<u>快速排序是所有内部排序算法中平均性能最优的排序算法</u>**.

**稳定性**：是一种**不稳定**的算法。若右端有两个关键字相同，如上述示例中的 $49,\bar{49}$ ，排序后的相对次序已发生变化。

> ❗在快速排序汇总，并**不产生有序的子序列**，但每趟排序后都会将**枢纽元素放置最终位置**。



## 选择排序




### 简单选择排序

每一趟在后面 *n-i+1*个中选出关键码最小的对象, 作为有序序列的第 *i* 个记录。对于 $n=6$ 的例子：

1. $i=1$ 时，在 $6-1+1 = 6$ 个元素中选取最小的元素 $08$ 作为第 $i=1$ 位：

<img src="https://cdn.notcloud.net/static/md/cy948/202211201722503.png" alt="image-20221120172212446" style="zoom:50%;" />

🔁 以此类推：

<img src="https://cdn.notcloud.net/static/md/cy948/202211201725896.png" alt="image-20221120172506847" style="zoom:50%;" />

**算法**

```c
void swap(ElemType a, ElemType b);// 交换两个元素
void SelectSort(SqList * L){
    //从第一位开始
    for (i=1; i<L.length; ++i){
    //在L.r[i..L.length] 中选择key最小的记录
		int min = i,j;//记录最小元素的下标
        //寻找更小的元素
        for(j=i+1; j<=L.length; j++){
            if(L.r[j].key<L.r[min].key) min=j;
        }
        //如果存在更小的元素，则交换位置
        if(min!=i) swap(L.r[i],L.r[min]);
    }  
}
```



**性能分析**

**空间效率**：仅使用常数个辅助单元，故空间效率为 $O(1)$ ；

**时间效率**：

- *元素移动* ：不会超过 $3(n-1)$ 次，最好的情况是 0 次；
- 比较次数：**与序列初始状态无关**，始终是 $n(n-1)/ 2$ 次，复杂度 $O(n^2)$ ；

**稳定性**：**不稳定**。如上图过程中的 $25,25^*$ ，在 $i=2$ 时，$25$ 已被交换到 $25^*$ 后面；



### 堆排序

> 产生背景：简单选择排序没有利用上次选择的结果，是造成速度慢的重要原因。如果能够加以改进，将会提高排序的速度。

#### 定义及手动模拟

堆的定义如下：*n* 个关键字序列 $L[1...n]$ 称为堆，需满足以下其中之一：

① $L(i) \ge L(2i) \ \text{并且} \ L(i) \ge L(2i+1)$ ；
② $L(i) \le L(2i) \ \text{并且} \ L(i) \le L(2i+1)(1 \le i \le \lfloor n/2 \rfloor )$ ；

可以将该一维数组视为一颗 *完全二叉树* ，满足条件 ① 的堆称为 **大顶堆** （**大根堆，最大堆**），*大根堆* 的最大元素存放在根节点，且其任一非根节点的值小于等于其双亲结点的值。满足条件②的堆称为 **小顶堆**（**小根堆，最小堆**）。

> 利用树的结构特征只是堆的描述工具，堆**实际存放在线性空间中**。

堆排序过程的关键是“构造”初始堆，要理解从数组到树的映射（❗知道谁是谁的孩子）、如何进行初次调整。

<img src="https://cdn.notcloud.net/static/md/cy948/202211201953454.png" alt="image-20221120195324412" style="zoom:80%;" />

<center>
    数组到树的映射
</center>

1. 建堆，这一步并无实质性的代码。如图，按“层序”把数组“建成”树。❗**规律**：对于一个结点 $L(i)$ (第几个，以下都不是下标)，其左孩子为：$L(2*i)$，右孩子为 $L(2*i+1)$；
2. *n* 个结点的完全二叉树，其最后一个结点是 $\lfloor n/2 \rfloor$ 个结点的孩子。上图中，$c$，意味着最后一个结点 $L(8)$ 是 $L(4)$ 的孩子；
3. 建堆后第一次调整。以 $L(\lfloor n/2 \rfloor) \to L(4)$ 为根的子树筛选，若左右结点中的值大于（大根堆，小根堆则相反）根结点，则交换（选大的进行交换）；🔁之后**依次**对各结点为根（$\lfloor n/2 \rfloor - 1 = 3$）的子树（这个范围划分已经排除了所有叶结点）进行筛选。🤔过程中可能会影响其他堆，所以从后往前调。
4. 到根节点 $i == 1$，停止。

以下是**建立初始堆**过程：

> 以下均针对 **图 8.5**

- 如图 `a` ：第一次调整，对以$L(\lfloor n/2 \rfloor) \to L(4)$ 为根的子树进行调整，$09<32$，交换；
- 如图 `b` ：第一次调整完成后，从 $\lfloor n/2 \rfloor - 1 = 3 \to L(3)$ 为根的子树开始调整，$78<\max\{65,87\}$ ，与 $87$ 交换；
- 如图 `c` ：对 $L(2)$ 为根的子树进行调整，$17<\max\{32,45\}$ ，与 $45$ 进行交换；
- 如图 `d` ：对 $L(1)$ 为根的子树进行调整，$53<\max\{45,87\}$ ，与 $87$ 进行交换；

![image-20221120194923105](https://cdn.notcloud.net/static/md/cy948/202211201949153.png)

此时，堆已完成建立，往后只需要不断去掉根节点，然后重复调整过程即可。

**去根节点后调整过程**

将最后一个元素 $09$ 和顶元素 $87$ 进行交换，此时性质被破坏，需要**从上往下**进行筛选。

> 看 **图 8.6**

- `左` 将根节点 $L(1)$ 的左右孩子 $\max\{L(1*2).key,L(1*2+1).key\}$ 中较大的一个 $L(3)$ 与其交换；
- `中` 交换后破坏了根结点右孩子 $L(3)$ 为根的子树的性质，需对其进行调整，遂与 $\max\{L(3*2).key,L(3*2+1).key\}$ 进行交换；
- `右` 已经是叶结点了，停停停。

#### 算法

分为三个子函数：

```c
void CreateHeap(SqList * L); 
//把无序序列L.r[1~L.length]建成大根堆

void HeapSort(SqList * L);
//对L.r[1~L.length]进行非降序排序

void HeapAdjust(SqList * L, int s, int m); // s 是根结点, m 是总长度
//r[s+1..m]已经是堆，将r[s..m]调整为以r[s]为根的大根堆
```

功能逻辑：`HeapSort` 为主函数，先调用 `CreateHeap` 建立初始堆，然后不断弹出元素，再调整各子树；

```c
void CreateHeap(SqList * L)
{//把无序序列L.r[1~L.length]建成大根堆
    /*如上文，“建立” 这个过程无实质性的代码*/
    //第一次调整堆，同上手动模拟中的“建立初始堆”
    int n = L.length;
    for(i=n/2;//向下取整计算n/2，获得最后一个结点的父结点
        i>0; i-- //同手动模拟中的 3. 从 n/2 开始调整堆
       ){
		HeapAdjust(L, i, n);  //把L.r[i~n]调整为大根堆
    }//for
}

void HeapSort(SqList * L)
{//对L.r[1~L.length]进行非降序排序
    CreateHeap(L);//建大根堆
    int i,x;
    //大根堆的堆顶元素是L[1]~L[i]的最大值
    //将第一位的最大值与最后一位进行交换，放到末尾
    //从此可得该算法每一步都确定一个元素的最终位置
    //同手动模拟中的“去根节点”过程，不断将首元素与尾元素交换
    for(i=L.length; i>1; i--){
        //交换首尾元素，然后调整排序区域的长度
		x = L.r[1];// L.r[1] 与 L.r[i] 交换      
        L.r[1] = L.r[i];
        L.r[i] = x;
        //此时，因为已经找出 1~i 的最大元素，
        //故只需从上往下调整 1~i-1 的元素
        HeapAdjust(L, 1, i-1);  //把L.r[1~i-1]调整为大根堆
    }
}

void HeapAdjust(SqList * L, int s, int m)
{ //r[s+1..m]已经是堆，将r[s..m]调整为以r[s]为根的大根堆
	//同手动模拟中的从上往下的调整
    L.r[0] = L.r[s];//暂存子树的根结点到L.r[0]
    for(
        j=2*s;//2*s 指以 s 为根的结点的左孩子
        j<=m;//限定调整范围
        j*=2 //手动模拟中的“调整过程”，
        //如对 j 进行交换，则要重新对以 j 为根的子树进行调整
       ){
		if(
            j<m //j<m 检查孩子是否存在
            && L.r[j].key<L.r[j+1].key 
           //如果左孩子比右孩子小，则选右孩子
          ) ++j;//选择右孩子
        //如果孩子都不大于根结点s的值，则调整结束
		if(L.r[0].key >= L.r[j].key) break;
        //如果需要交换，则根节点与孩子 j 进行交换
        L.r[s] = L.r[j];
        /*这里是一个优化点，
        此处暂不需要对原根节点的值进行修改，
        只需用 s 保存根结点的目标位置，
        因为有可能根节点会再往下走*/
		s = j;//修改 s 为孩子的位置
    }
    //上面的优化的后续，一次性修改原根节点的位置
    L.r[s] = L.r[0];//从暂存中恢复根节点的值到目标位置L[s]
}
```



#### 插入及删除

插入时放在尾端，



#### 性能分析



**空间效率**：仅使用常数个辅助单元，所以空间复杂度为 $O(1)$ ;

**时间效率**：建堆时间为 $O(n)$ ，之后有 *n-1* 次向下调整操作，每次调整的时间复杂度为 $O(h)$ 故在最好、最坏和平均情况下，堆排序的复杂度为 $O(n \log_2 n)$ ；

**稳定性**：**不稳定**。进行筛选，有可能把后面相同的关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序方法。如标 $L=\{1,2*,2\}$ 中，构造初始堆时有可能将 $2*$ 交换到堆顶，此时 $L=\{2*,1,2\}$ ，最终排序序列为 $L=\{1,2,2*\}$ ；



附 [912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/) 如果数组是从0开始的，则注意一下几点问题：

- 左孩子的位置的公式 变为 `lchild = (parent + 1) * 2 - 1;` 
- 最后一个孩子的公式 变为 `(n / 2) - 1;`
- `createHeap` 中调整的范围，原来是 `i>0` 变为 `i>=0` 因为[0]的根节点也要调整；
- `sortArray` 中对 `heapAdjust` 方法调用时的参数不是 `i-1` ；
- `heapAdjust` 中对结点存在的判断也许调整；


```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
*/
int getLeftChild(int parent){
    return (parent + 1) * 2 - 1;
}
int getParentOfLastChild(int numsSize){
    return (numsSize / 2) - 1;
}
// 调整堆
void heapAdjust(int* heap, int root,int heapSize){
    int rc = heap[root], j;//暂存根节点
    for(
            j = getLeftChild(root);//找到根结点的左孩子位置，赋给j
            j < heapSize;//存在该子结点
            j = getLeftChild(j)//以调整的孩子作为根再调整
       ){
        if(
                j<heapSize-1 &&//若存在右孩子
                heap[j] < heap[j+1] //且左孩子小于右孩子
          ) ++j;//则选择右孩子去和根结点比较
        //如果最大的孩子比根结点小，结束
        if(heap[j] < rc) break;
        //否，则先把孩子交换到根结点的位置，
        //继续寻找根结点的下一位置
        heap[root] = heap[j];
        //更新根结点的位置
        root = j;
    }
    //完成循环后，找到根节点的位置，放到位置中
    heap[root] = rc;
}
// 初始化大顶堆
void createHeap(int* nums, int numsSize){
    int i;
    //从最后一个结点的父结点开始调整堆
    for(i = getParentOfLastChild(numsSize); i >= 0; i--){
        heapAdjust(nums, i, numsSize);
    }
}
int* sortArray(int* nums, int numsSize, int* returnSize){
    createHeap(nums, numsSize);//建大顶堆
    int i,tmp;
    //不断获取最大值，调整堆，此处与上面明显不同
    for(i = numsSize-1; i > 0; i--){
        //将第一个元素与最后进行交换
        tmp = nums[0];
        nums[0] = nums[i];
        nums[i] = tmp;
        //调整堆，只需要调整 0~i
        heapAdjust(nums, 0, i);
    }
    // 修改返回数组大小后返回，堆排序为原地修改，直接返回原数组即可
    * returnSize = numsSize;
    return nums;
}
```



## 归并排序和基数排序

### 归并排序

>  归并排序与上述基于交换、选择的排序不同，“归并”的意义是将两个或以上的有序表组合成一个新的有序表。

假定待排序表含有  *n* 个记录，则可将其视为 *n* 个有序的子表，每个长度为 *1* ，然后两两归并，得到$\lceil n/2 \rceil$ 个长度为 *2* 为 *1* 的有序表；继续两两归并 ... ... 如此重复直到合并成一个长度为 *n* 的有序表位置，这种排序方式才成为 *2* 路归并排序。

![localtestwithplugins](https://cdn.notcloud.net/static/md/cy948/202211292157232.gif)

如果直接对数组进行排序，上述的伪代码中有部分需要改动：也是[912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/)

```c
void MSort(int* nums, int low, int high);
void Merge(int* nums, int low, int mid, int high);

int* sortArray(int* nums, int numsSize, int* returnSize){
    MSort(nums, 0, numsSize-1);
    * returnSize = numsSize;
    return nums;
}

void MSort(int* nums, int low, int high){
    //只有一个元素时自然有序，无需再排
    if(low == high) return;
    
    int mid = low + (high - low)/2;
    MSort(nums, low, mid);//对左段进行排序
    MSort(nums, mid+1, high);//对右段进行排序
    Merge(nums, low, mid, high);//归并左右两段
}

void Merge(int* nums, int low, int mid, int high){
    int toSofted[high+1], tmpLow;
    // 复制待排序的元素到临时数组，使用从临时数组中选择元素覆盖到原数组的做法
    for(tmpLow = low; tmpLow <= high; tmpLow++) toSofted[tmpLow] = nums[tmpLow];

    // i指向待合并数组最左边的元素，j是右数组最左边的元素
    // resIdx 是结果数组的指针
    int i = low, j = mid+1, resIdx = low;

    while(i <= mid && j <= high){
        //复制左数组的元素到结果数组
			//左边的元素小，复制左边的元素到临时数组中，
	        //并移动指针指向左边的下一个元素起点
        if(toSofted[i] <= toSofted[j]) nums[resIdx++] = toSofted[i++];
        else nums[resIdx++] = toSofted[j++];
    }

    //处理剩余的元素
    //左边数组元素未处理完，依次复制到结果数组
    while(i <= mid) nums[resIdx++] = toSofted[i++];
    while(j <= high) nums[resIdx++] = toSofted[j++];
    //上面两个while只有一个会执行
}
```

#### 性能分析

**时间复杂度**
        每一趟归并的时间复杂度为 $O(n)$，总共需进行 $\lceil \log_2 n \rceil$ 趟。故：对 n 个记录进行归并排序的时间复杂度为 $Ο(n\log_2 n)$ ；

**空间复杂度**
        `Merge()`方法中使用了的辅助数组 `toSofted` ，故空间复杂度是O(n).

### 基数排序

